// <auto-generated />
// Built from: hl7.fhir.r4b.core version: 4.1.0
  // Option: "NAMESPACE" = "fhirCsR4"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR4.Serialization;

namespace fhirCsR4.Models
{
  /// <summary>
  /// If there is no discriminator, the content is hard to process, so this should be avoided.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<ElementDefinitionSlicingDiscriminator>))]
  public class ElementDefinitionSlicingDiscriminator : Element,  IFhirJsonSerializable {
    /// <summary>
    /// The only FHIRPath functions that are allowed are as(type), resolve(), and extension(url).
    /// </summary>
    public string Path { get; set; }
    /// <summary>
    /// Extension container element for Path
    /// </summary>
    public Element _Path { get; set; }
    /// <summary>
    /// How the element value is interpreted when discrimination is evaluated.
    /// </summary>
    public string Type { get; set; }
    /// <summary>
    /// Extension container element for Type
    /// </summary>
    public Element _Type { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Type))
      {
        writer.WriteString("type", (string)Type!);
      }

      if (_Type != null)
      {
        writer.WritePropertyName("_type");
        _Type.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Path))
      {
        writer.WriteString("path", (string)Path!);
      }

      if (_Path != null)
      {
        writer.WritePropertyName("_path");
        _Path.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "path":
          Path = reader.GetString();
          break;

        case "_path":
          _Path = new fhirCsR4.Models.Element();
          _Path.DeserializeJson(ref reader, options);
          break;

        case "type":
          Type = reader.GetString();
          break;

        case "_type":
          _Type = new fhirCsR4.Models.Element();
          _Type.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ElementDefinition.slicing.discriminator.type field
  /// </summary>
  public static class ElementDefinitionSlicingDiscriminatorTypeCodes {
    public const string VALUE = "value";
    public const string EXISTS = "exists";
    public const string PATTERN = "pattern";
    public const string TYPE = "type";
    public const string PROFILE = "profile";
  }
  /// <summary>
  /// The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<ElementDefinitionSlicing>))]
  public class ElementDefinitionSlicing : Element,  IFhirJsonSerializable {
    /// <summary>
    /// If it's really not possible to differentiate them, the design should be re-evaluated to make the content usable.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// If there is no discriminator, the content is hard to process, so this should be avoided.
    /// </summary>
    public List<ElementDefinitionSlicingDiscriminator> Discriminator { get; set; }
    /// <summary>
    /// Order should only be required when it is a pressing concern for presentation. Profile authors should consider making the order a feature of the rules about the narrative, not the rules about the data - requiring ordered data makes the profile much less re-usable.
    /// </summary>
    public bool? Ordered { get; set; }
    /// <summary>
    /// Allowing additional elements makes for a much for flexible template - it's open for use in wider contexts, but also means that the content of the resource is not closed, and applications have to decide how to handle content not described by the profile.
    /// </summary>
    public string Rules { get; set; }
    /// <summary>
    /// Extension container element for Rules
    /// </summary>
    public Element _Rules { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.Element)this).SerializeJson(writer, options, false);

      if ((Discriminator != null) && (Discriminator.Count != 0))
      {
        writer.WritePropertyName("discriminator");
        writer.WriteStartArray();

        foreach (ElementDefinitionSlicingDiscriminator valDiscriminator in Discriminator)
        {
          valDiscriminator.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if (Ordered != null)
      {
        writer.WriteBoolean("ordered", (bool)Ordered!);
      }

      if (!string.IsNullOrEmpty(Rules))
      {
        writer.WriteString("rules", (string)Rules!);
      }

      if (_Rules != null)
      {
        writer.WritePropertyName("_rules");
        _Rules.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR4.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "discriminator":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Discriminator = new List<ElementDefinitionSlicingDiscriminator>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ElementDefinitionSlicingDiscriminator objDiscriminator = new fhirCsR4.Models.ElementDefinitionSlicingDiscriminator();
            objDiscriminator.DeserializeJson(ref reader, options);
            Discriminator.Add(objDiscriminator);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Discriminator.Count == 0)
          {
            Discriminator = null;
          }

          break;

        case "ordered":
          Ordered = reader.GetBoolean();
          break;

        case "rules":
          Rules = reader.GetString();
          break;

        case "_rules":
          _Rules = new fhirCsR4.Models.Element();
          _Rules.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ElementDefinition.slicing.rules field
  /// </summary>
  public static class ElementDefinitionSlicingRulesCodes {
    public const string CLOSED = "closed";
    public const string OPEN = "open";
    public const string OPENATEND = "openAtEnd";
  }
  /// <summary>
  /// The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. For tooling simplicity, the base information must always be populated in element definitions in snap shots, even if it is the same.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<ElementDefinitionBase>))]
  public class ElementDefinitionBase : Element,  IFhirJsonSerializable {
    /// <summary>
    /// This is provided to code generation, since the serialization representation in JSON differs depending on whether the base element has max &gt; 1. Also, some forms of code generation may differ.
    /// </summary>
    public string Max { get; set; }
    /// <summary>
    /// Extension container element for Max
    /// </summary>
    public Element _Max { get; set; }
    /// <summary>
    /// This is provided for consistency with max, and may affect code generation of mandatory elements of the base resource are generated differently (some reference implementations have done this).
    /// </summary>
    public uint Min { get; set; }
    /// <summary>
    /// The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [StructureDefinition](structuredefinition.html#) without a StructureDefinition.base.
    /// </summary>
    public string Path { get; set; }
    /// <summary>
    /// Extension container element for Path
    /// </summary>
    public Element _Path { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Path))
      {
        writer.WriteString("path", (string)Path!);
      }

      if (_Path != null)
      {
        writer.WritePropertyName("_path");
        _Path.SerializeJson(writer, options);
      }

      writer.WriteNumber("min", Min);

      if (!string.IsNullOrEmpty(Max))
      {
        writer.WriteString("max", (string)Max!);
      }

      if (_Max != null)
      {
        writer.WritePropertyName("_max");
        _Max.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "max":
          Max = reader.GetString();
          break;

        case "_max":
          _Max = new fhirCsR4.Models.Element();
          _Max.DeserializeJson(ref reader, options);
          break;

        case "min":
          Min = reader.GetUInt32();
          break;

        case "path":
          Path = reader.GetString();
          break;

        case "_path":
          _Path = new fhirCsR4.Models.Element();
          _Path.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<ElementDefinitionType>))]
  public class ElementDefinitionType : Element,  IFhirJsonSerializable {
    /// <summary>
    /// See [Aggregation Rules](elementdefinition.html#aggregation) for further clarification.
    /// </summary>
    public List<string> Aggregation { get; set; }
    /// <summary>
    /// Extension container element for Aggregation
    /// </summary>
    public List<Element> _Aggregation { get; set; }
    /// <summary>
    /// If the element is a reference to another resource, this element contains "Reference", and the targetProfile element defines what resources can be referenced. The targetProfile may be a reference to the general definition of a resource (e.g. http://hl7.org/fhir/StructureDefinition/Patient).
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// It is possible to profile  backbone element (e.g. part of a resource), using the [profile-element](extension-elementdefinition-profile-element.html) extension.
    /// </summary>
    public List<string> Profile { get; set; }
    /// <summary>
    /// Extension container element for Profile
    /// </summary>
    public List<Element> _Profile { get; set; }
    /// <summary>
    /// Used when the type is "Reference" or "canonical", and identifies a profile structure or implementation Guide that applies to the target of the reference this element refers to. If any profiles are specified, then the content must conform to at least one of them. The URL can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the target resource SHALL conform to at least one profile defined in the implementation guide.
    /// </summary>
    public List<string> TargetProfile { get; set; }
    /// <summary>
    /// Extension container element for TargetProfile
    /// </summary>
    public List<Element> _TargetProfile { get; set; }
    /// <summary>
    /// The base specification never makes a rule as to which form is allowed, but implementation guides may do this. See [Aggregation Rules](elementdefinition.html#aggregation) for further clarification.
    /// </summary>
    public string Versioning { get; set; }
    /// <summary>
    /// Extension container element for Versioning
    /// </summary>
    public Element _Versioning { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Code))
      {
        writer.WriteString("code", (string)Code!);
      }

      if (_Code != null)
      {
        writer.WritePropertyName("_code");
        _Code.SerializeJson(writer, options);
      }

      if ((Profile != null) && (Profile.Count != 0))
      {
        writer.WritePropertyName("profile");
        writer.WriteStartArray();

        foreach (string valProfile in Profile)
        {
          writer.WriteStringValue(valProfile);
        }

        writer.WriteEndArray();
      }

      if ((_Profile != null) && (_Profile.Count != 0))
      {
        writer.WritePropertyName("_profile");
        writer.WriteStartArray();

        foreach (Element val_Profile in _Profile)
        {
          val_Profile.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((TargetProfile != null) && (TargetProfile.Count != 0))
      {
        writer.WritePropertyName("targetProfile");
        writer.WriteStartArray();

        foreach (string valTargetProfile in TargetProfile)
        {
          writer.WriteStringValue(valTargetProfile);
        }

        writer.WriteEndArray();
      }

      if ((_TargetProfile != null) && (_TargetProfile.Count != 0))
      {
        writer.WritePropertyName("_targetProfile");
        writer.WriteStartArray();

        foreach (Element val_TargetProfile in _TargetProfile)
        {
          val_TargetProfile.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Aggregation != null) && (Aggregation.Count != 0))
      {
        writer.WritePropertyName("aggregation");
        writer.WriteStartArray();

        foreach (string valAggregation in Aggregation)
        {
          writer.WriteStringValue(valAggregation);
        }

        writer.WriteEndArray();
      }

      if ((_Aggregation != null) && (_Aggregation.Count != 0))
      {
        writer.WritePropertyName("_aggregation");
        writer.WriteStartArray();

        foreach (Element val_Aggregation in _Aggregation)
        {
          val_Aggregation.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Versioning))
      {
        writer.WriteString("versioning", (string)Versioning!);
      }

      if (_Versioning != null)
      {
        writer.WritePropertyName("_versioning");
        _Versioning.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "aggregation":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Aggregation = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Aggregation.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Aggregation.Count == 0)
          {
            Aggregation = null;
          }

          break;

        case "_aggregation":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Aggregation = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Element obj_Aggregation = new fhirCsR4.Models.Element();
            obj_Aggregation.DeserializeJson(ref reader, options);
            _Aggregation.Add(obj_Aggregation);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Aggregation.Count == 0)
          {
            _Aggregation = null;
          }

          break;

        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new fhirCsR4.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "profile":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Profile = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Profile.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Profile.Count == 0)
          {
            Profile = null;
          }

          break;

        case "_profile":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Profile = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Element obj_Profile = new fhirCsR4.Models.Element();
            obj_Profile.DeserializeJson(ref reader, options);
            _Profile.Add(obj_Profile);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Profile.Count == 0)
          {
            _Profile = null;
          }

          break;

        case "targetProfile":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          TargetProfile = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            TargetProfile.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (TargetProfile.Count == 0)
          {
            TargetProfile = null;
          }

          break;

        case "_targetProfile":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _TargetProfile = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Element obj_TargetProfile = new fhirCsR4.Models.Element();
            obj_TargetProfile.DeserializeJson(ref reader, options);
            _TargetProfile.Add(obj_TargetProfile);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_TargetProfile.Count == 0)
          {
            _TargetProfile = null;
          }

          break;

        case "versioning":
          Versioning = reader.GetString();
          break;

        case "_versioning":
          _Versioning = new fhirCsR4.Models.Element();
          _Versioning.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ElementDefinition.type.aggregation field
  /// </summary>
  public static class ElementDefinitionTypeAggregationCodes {
    public const string CONTAINED = "contained";
    public const string REFERENCED = "referenced";
    public const string BUNDLED = "bundled";
  }
  /// <summary>
  /// Code Values for the ElementDefinition.type.versioning field
  /// </summary>
  public static class ElementDefinitionTypeVersioningCodes {
    public const string EITHER = "either";
    public const string INDEPENDENT = "independent";
    public const string SPECIFIC = "specific";
  }
  /// <summary>
  /// Examples will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<ElementDefinitionExample>))]
  public class ElementDefinitionExample : Element,  IFhirJsonSerializable {
    /// <summary>
    /// Describes the purpose of this example amoung the set of examples.
    /// </summary>
    public string Label { get; set; }
    /// <summary>
    /// Extension container element for Label
    /// </summary>
    public Element _Label { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public byte[] ValueBase64Binary { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public bool? ValueBoolean { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueCanonical { get; set; }
    /// <summary>
    /// Extension container element for ValueCanonical
    /// </summary>
    public Element _ValueCanonical { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueCode { get; set; }
    /// <summary>
    /// Extension container element for ValueCode
    /// </summary>
    public Element _ValueCode { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueDate { get; set; }
    /// <summary>
    /// Extension container element for ValueDate
    /// </summary>
    public Element _ValueDate { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for ValueDateTime
    /// </summary>
    public Element _ValueDateTime { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public decimal? ValueDecimal { get; set; }
    /// <summary>
    /// Extension container element for ValueDecimal
    /// </summary>
    public Element _ValueDecimal { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueId { get; set; }
    /// <summary>
    /// Extension container element for ValueId
    /// </summary>
    public Element _ValueId { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueInstant { get; set; }
    /// <summary>
    /// Extension container element for ValueInstant
    /// </summary>
    public Element _ValueInstant { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public int? ValueInteger { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueMarkdown { get; set; }
    /// <summary>
    /// Extension container element for ValueMarkdown
    /// </summary>
    public Element _ValueMarkdown { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueOid { get; set; }
    /// <summary>
    /// Extension container element for ValueOid
    /// </summary>
    public Element _ValueOid { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public uint? ValuePositiveInt { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueString { get; set; }
    /// <summary>
    /// Extension container element for ValueString
    /// </summary>
    public Element _ValueString { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueTime { get; set; }
    /// <summary>
    /// Extension container element for ValueTime
    /// </summary>
    public Element _ValueTime { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public uint? ValueUnsignedInt { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueUri { get; set; }
    /// <summary>
    /// Extension container element for ValueUri
    /// </summary>
    public Element _ValueUri { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public string ValueUrl { get; set; }
    /// <summary>
    /// Extension container element for ValueUrl
    /// </summary>
    public Element _ValueUrl { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Guid? ValueUuid { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Address ValueAddress { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Age ValueAge { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Annotation ValueAnnotation { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Attachment ValueAttachment { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public CodeableConcept ValueCodeableConcept { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Coding ValueCoding { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public ContactPoint ValueContactPoint { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Count ValueCount { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Distance ValueDistance { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Duration ValueDuration { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public HumanName ValueHumanName { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Identifier ValueIdentifier { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Money ValueMoney { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Period ValuePeriod { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Quantity ValueQuantity { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Range ValueRange { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Ratio ValueRatio { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Reference ValueReference { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public SampledData ValueSampledData { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Signature ValueSignature { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Timing ValueTiming { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public ContactDetail ValueContactDetail { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Contributor ValueContributor { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public DataRequirement ValueDataRequirement { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Expression ValueExpression { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public ParameterDefinition ValueParameterDefinition { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public RelatedArtifact ValueRelatedArtifact { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public TriggerDefinition ValueTriggerDefinition { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public UsageContext ValueUsageContext { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Dosage ValueDosage { get; set; }
    /// <summary>
    /// The actual value for the element, which must be one of the types allowed for this element.
    /// </summary>
    public Meta ValueMeta { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Label))
      {
        writer.WriteString("label", (string)Label!);
      }

      if (_Label != null)
      {
        writer.WritePropertyName("_label");
        _Label.SerializeJson(writer, options);
      }

      if (ValueBase64Binary != null)
      {
        writer.WriteString("valueBase64Binary", System.Convert.ToBase64String(ValueBase64Binary));
      }

      if (ValueBoolean != null)
      {
        writer.WriteBoolean("valueBoolean", (bool)ValueBoolean!);
      }

      if (!string.IsNullOrEmpty(ValueCanonical))
      {
        writer.WriteString("valueCanonical", (string)ValueCanonical!);
      }

      if (_ValueCanonical != null)
      {
        writer.WritePropertyName("_valueCanonical");
        _ValueCanonical.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueCode))
      {
        writer.WriteString("valueCode", (string)ValueCode!);
      }

      if (_ValueCode != null)
      {
        writer.WritePropertyName("_valueCode");
        _ValueCode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueDate))
      {
        writer.WriteString("valueDate", (string)ValueDate!);
      }

      if (_ValueDate != null)
      {
        writer.WritePropertyName("_valueDate");
        _ValueDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueDateTime))
      {
        writer.WriteString("valueDateTime", (string)ValueDateTime!);
      }

      if (_ValueDateTime != null)
      {
        writer.WritePropertyName("_valueDateTime");
        _ValueDateTime.SerializeJson(writer, options);
      }

      if (ValueDecimal != null)
      {
        writer.WriteNumber("valueDecimal", (decimal)ValueDecimal!);
      }

      if (_ValueDecimal != null)
      {
        writer.WritePropertyName("_valueDecimal");
        _ValueDecimal.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueId))
      {
        writer.WriteString("valueId", (string)ValueId!);
      }

      if (_ValueId != null)
      {
        writer.WritePropertyName("_valueId");
        _ValueId.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueInstant))
      {
        writer.WriteString("valueInstant", (string)ValueInstant!);
      }

      if (_ValueInstant != null)
      {
        writer.WritePropertyName("_valueInstant");
        _ValueInstant.SerializeJson(writer, options);
      }

      if (ValueInteger != null)
      {
        writer.WriteNumber("valueInteger", (int)ValueInteger!);
      }

      if (!string.IsNullOrEmpty(ValueMarkdown))
      {
        writer.WriteString("valueMarkdown", (string)ValueMarkdown!);
      }

      if (_ValueMarkdown != null)
      {
        writer.WritePropertyName("_valueMarkdown");
        _ValueMarkdown.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueOid))
      {
        writer.WriteString("valueOid", (string)ValueOid!);
      }

      if (_ValueOid != null)
      {
        writer.WritePropertyName("_valueOid");
        _ValueOid.SerializeJson(writer, options);
      }

      if (ValuePositiveInt != null)
      {
        writer.WriteNumber("valuePositiveInt", (uint)ValuePositiveInt!);
      }

      if (!string.IsNullOrEmpty(ValueString))
      {
        writer.WriteString("valueString", (string)ValueString!);
      }

      if (_ValueString != null)
      {
        writer.WritePropertyName("_valueString");
        _ValueString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueTime))
      {
        writer.WriteString("valueTime", (string)ValueTime!);
      }

      if (_ValueTime != null)
      {
        writer.WritePropertyName("_valueTime");
        _ValueTime.SerializeJson(writer, options);
      }

      if (ValueUnsignedInt != null)
      {
        writer.WriteNumber("valueUnsignedInt", (uint)ValueUnsignedInt!);
      }

      if (!string.IsNullOrEmpty(ValueUri))
      {
        writer.WriteString("valueUri", (string)ValueUri!);
      }

      if (_ValueUri != null)
      {
        writer.WritePropertyName("_valueUri");
        _ValueUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueUrl))
      {
        writer.WriteString("valueUrl", (string)ValueUrl!);
      }

      if (_ValueUrl != null)
      {
        writer.WritePropertyName("_valueUrl");
        _ValueUrl.SerializeJson(writer, options);
      }

      if (ValueUuid != null)
      {
        writer.WriteString("valueUuid", (Guid)ValueUuid!);
      }

      if (ValueAddress != null)
      {
        writer.WritePropertyName("valueAddress");
        ValueAddress.SerializeJson(writer, options);
      }

      if (ValueAge != null)
      {
        writer.WritePropertyName("valueAge");
        ValueAge.SerializeJson(writer, options);
      }

      if (ValueAnnotation != null)
      {
        writer.WritePropertyName("valueAnnotation");
        ValueAnnotation.SerializeJson(writer, options);
      }

      if (ValueAttachment != null)
      {
        writer.WritePropertyName("valueAttachment");
        ValueAttachment.SerializeJson(writer, options);
      }

      if (ValueCodeableConcept != null)
      {
        writer.WritePropertyName("valueCodeableConcept");
        ValueCodeableConcept.SerializeJson(writer, options);
      }

      if (ValueCoding != null)
      {
        writer.WritePropertyName("valueCoding");
        ValueCoding.SerializeJson(writer, options);
      }

      if (ValueContactPoint != null)
      {
        writer.WritePropertyName("valueContactPoint");
        ValueContactPoint.SerializeJson(writer, options);
      }

      if (ValueCount != null)
      {
        writer.WritePropertyName("valueCount");
        ValueCount.SerializeJson(writer, options);
      }

      if (ValueDistance != null)
      {
        writer.WritePropertyName("valueDistance");
        ValueDistance.SerializeJson(writer, options);
      }

      if (ValueDuration != null)
      {
        writer.WritePropertyName("valueDuration");
        ValueDuration.SerializeJson(writer, options);
      }

      if (ValueHumanName != null)
      {
        writer.WritePropertyName("valueHumanName");
        ValueHumanName.SerializeJson(writer, options);
      }

      if (ValueIdentifier != null)
      {
        writer.WritePropertyName("valueIdentifier");
        ValueIdentifier.SerializeJson(writer, options);
      }

      if (ValueMoney != null)
      {
        writer.WritePropertyName("valueMoney");
        ValueMoney.SerializeJson(writer, options);
      }

      if (ValuePeriod != null)
      {
        writer.WritePropertyName("valuePeriod");
        ValuePeriod.SerializeJson(writer, options);
      }

      if (ValueQuantity != null)
      {
        writer.WritePropertyName("valueQuantity");
        ValueQuantity.SerializeJson(writer, options);
      }

      if (ValueRange != null)
      {
        writer.WritePropertyName("valueRange");
        ValueRange.SerializeJson(writer, options);
      }

      if (ValueRatio != null)
      {
        writer.WritePropertyName("valueRatio");
        ValueRatio.SerializeJson(writer, options);
      }

      if (ValueReference != null)
      {
        writer.WritePropertyName("valueReference");
        ValueReference.SerializeJson(writer, options);
      }

      if (ValueSampledData != null)
      {
        writer.WritePropertyName("valueSampledData");
        ValueSampledData.SerializeJson(writer, options);
      }

      if (ValueSignature != null)
      {
        writer.WritePropertyName("valueSignature");
        ValueSignature.SerializeJson(writer, options);
      }

      if (ValueTiming != null)
      {
        writer.WritePropertyName("valueTiming");
        ValueTiming.SerializeJson(writer, options);
      }

      if (ValueContactDetail != null)
      {
        writer.WritePropertyName("valueContactDetail");
        ValueContactDetail.SerializeJson(writer, options);
      }

      if (ValueContributor != null)
      {
        writer.WritePropertyName("valueContributor");
        ValueContributor.SerializeJson(writer, options);
      }

      if (ValueDataRequirement != null)
      {
        writer.WritePropertyName("valueDataRequirement");
        ValueDataRequirement.SerializeJson(writer, options);
      }

      if (ValueExpression != null)
      {
        writer.WritePropertyName("valueExpression");
        ValueExpression.SerializeJson(writer, options);
      }

      if (ValueParameterDefinition != null)
      {
        writer.WritePropertyName("valueParameterDefinition");
        ValueParameterDefinition.SerializeJson(writer, options);
      }

      if (ValueRelatedArtifact != null)
      {
        writer.WritePropertyName("valueRelatedArtifact");
        ValueRelatedArtifact.SerializeJson(writer, options);
      }

      if (ValueTriggerDefinition != null)
      {
        writer.WritePropertyName("valueTriggerDefinition");
        ValueTriggerDefinition.SerializeJson(writer, options);
      }

      if (ValueUsageContext != null)
      {
        writer.WritePropertyName("valueUsageContext");
        ValueUsageContext.SerializeJson(writer, options);
      }

      if (ValueDosage != null)
      {
        writer.WritePropertyName("valueDosage");
        ValueDosage.SerializeJson(writer, options);
      }

      if (ValueMeta != null)
      {
        writer.WritePropertyName("valueMeta");
        ValueMeta.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "label":
          Label = reader.GetString();
          break;

        case "_label":
          _Label = new fhirCsR4.Models.Element();
          _Label.DeserializeJson(ref reader, options);
          break;

        case "valueBase64Binary":
          ValueBase64Binary = System.Convert.FromBase64String(reader.GetString());
          break;

        case "valueBoolean":
          ValueBoolean = reader.GetBoolean();
          break;

        case "valueCanonical":
          ValueCanonical = reader.GetString();
          break;

        case "_valueCanonical":
          _ValueCanonical = new fhirCsR4.Models.Element();
          _ValueCanonical.DeserializeJson(ref reader, options);
          break;

        case "valueCode":
          ValueCode = reader.GetString();
          break;

        case "_valueCode":
          _ValueCode = new fhirCsR4.Models.Element();
          _ValueCode.DeserializeJson(ref reader, options);
          break;

        case "valueDate":
          ValueDate = reader.GetString();
          break;

        case "_valueDate":
          _ValueDate = new fhirCsR4.Models.Element();
          _ValueDate.DeserializeJson(ref reader, options);
          break;

        case "valueDateTime":
          ValueDateTime = reader.GetString();
          break;

        case "_valueDateTime":
          _ValueDateTime = new fhirCsR4.Models.Element();
          _ValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "valueDecimal":
          ValueDecimal = reader.GetDecimal();
          break;

        case "_valueDecimal":
          _ValueDecimal = new fhirCsR4.Models.Element();
          _ValueDecimal.DeserializeJson(ref reader, options);
          break;

        case "valueId":
          ValueId = reader.GetString();
          break;

        case "_valueId":
          _ValueId = new fhirCsR4.Models.Element();
          _ValueId.DeserializeJson(ref reader, options);
          break;

        case "valueInstant":
          ValueInstant = reader.GetString();
          break;

        case "_valueInstant":
          _ValueInstant = new fhirCsR4.Models.Element();
          _ValueInstant.DeserializeJson(ref reader, options);
          break;

        case "valueInteger":
          ValueInteger = reader.GetInt32();
          break;

        case "valueMarkdown":
          ValueMarkdown = reader.GetString();
          break;

        case "_valueMarkdown":
          _ValueMarkdown = new fhirCsR4.Models.Element();
          _ValueMarkdown.DeserializeJson(ref reader, options);
          break;

        case "valueOid":
          ValueOid = reader.GetString();
          break;

        case "_valueOid":
          _ValueOid = new fhirCsR4.Models.Element();
          _ValueOid.DeserializeJson(ref reader, options);
          break;

        case "valuePositiveInt":
          ValuePositiveInt = reader.GetUInt32();
          break;

        case "valueString":
          ValueString = reader.GetString();
          break;

        case "_valueString":
          _ValueString = new fhirCsR4.Models.Element();
          _ValueString.DeserializeJson(ref reader, options);
          break;

        case "valueTime":
          ValueTime = reader.GetString();
          break;

        case "_valueTime":
          _ValueTime = new fhirCsR4.Models.Element();
          _ValueTime.DeserializeJson(ref reader, options);
          break;

        case "valueUnsignedInt":
          ValueUnsignedInt = reader.GetUInt32();
          break;

        case "valueUri":
          ValueUri = reader.GetString();
          break;

        case "_valueUri":
          _ValueUri = new fhirCsR4.Models.Element();
          _ValueUri.DeserializeJson(ref reader, options);
          break;

        case "valueUrl":
          ValueUrl = reader.GetString();
          break;

        case "_valueUrl":
          _ValueUrl = new fhirCsR4.Models.Element();
          _ValueUrl.DeserializeJson(ref reader, options);
          break;

        case "valueUuid":
          ValueUuid = reader.GetGuid();
          break;

        case "valueAddress":
          ValueAddress = new fhirCsR4.Models.Address();
          ValueAddress.DeserializeJson(ref reader, options);
          break;

        case "valueAge":
          ValueAge = new fhirCsR4.Models.Age();
          ValueAge.DeserializeJson(ref reader, options);
          break;

        case "valueAnnotation":
          ValueAnnotation = new fhirCsR4.Models.Annotation();
          ValueAnnotation.DeserializeJson(ref reader, options);
          break;

        case "valueAttachment":
          ValueAttachment = new fhirCsR4.Models.Attachment();
          ValueAttachment.DeserializeJson(ref reader, options);
          break;

        case "valueCodeableConcept":
          ValueCodeableConcept = new fhirCsR4.Models.CodeableConcept();
          ValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "valueCoding":
          ValueCoding = new fhirCsR4.Models.Coding();
          ValueCoding.DeserializeJson(ref reader, options);
          break;

        case "valueContactPoint":
          ValueContactPoint = new fhirCsR4.Models.ContactPoint();
          ValueContactPoint.DeserializeJson(ref reader, options);
          break;

        case "valueCount":
          ValueCount = new fhirCsR4.Models.Count();
          ValueCount.DeserializeJson(ref reader, options);
          break;

        case "valueDistance":
          ValueDistance = new fhirCsR4.Models.Distance();
          ValueDistance.DeserializeJson(ref reader, options);
          break;

        case "valueDuration":
          ValueDuration = new fhirCsR4.Models.Duration();
          ValueDuration.DeserializeJson(ref reader, options);
          break;

        case "valueHumanName":
          ValueHumanName = new fhirCsR4.Models.HumanName();
          ValueHumanName.DeserializeJson(ref reader, options);
          break;

        case "valueIdentifier":
          ValueIdentifier = new fhirCsR4.Models.Identifier();
          ValueIdentifier.DeserializeJson(ref reader, options);
          break;

        case "valueMoney":
          ValueMoney = new fhirCsR4.Models.Money();
          ValueMoney.DeserializeJson(ref reader, options);
          break;

        case "valuePeriod":
          ValuePeriod = new fhirCsR4.Models.Period();
          ValuePeriod.DeserializeJson(ref reader, options);
          break;

        case "valueQuantity":
          ValueQuantity = new fhirCsR4.Models.Quantity();
          ValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "valueRange":
          ValueRange = new fhirCsR4.Models.Range();
          ValueRange.DeserializeJson(ref reader, options);
          break;

        case "valueRatio":
          ValueRatio = new fhirCsR4.Models.Ratio();
          ValueRatio.DeserializeJson(ref reader, options);
          break;

        case "valueReference":
          ValueReference = new fhirCsR4.Models.Reference();
          ValueReference.DeserializeJson(ref reader, options);
          break;

        case "valueSampledData":
          ValueSampledData = new fhirCsR4.Models.SampledData();
          ValueSampledData.DeserializeJson(ref reader, options);
          break;

        case "valueSignature":
          ValueSignature = new fhirCsR4.Models.Signature();
          ValueSignature.DeserializeJson(ref reader, options);
          break;

        case "valueTiming":
          ValueTiming = new fhirCsR4.Models.Timing();
          ValueTiming.DeserializeJson(ref reader, options);
          break;

        case "valueContactDetail":
          ValueContactDetail = new fhirCsR4.Models.ContactDetail();
          ValueContactDetail.DeserializeJson(ref reader, options);
          break;

        case "valueContributor":
          ValueContributor = new fhirCsR4.Models.Contributor();
          ValueContributor.DeserializeJson(ref reader, options);
          break;

        case "valueDataRequirement":
          ValueDataRequirement = new fhirCsR4.Models.DataRequirement();
          ValueDataRequirement.DeserializeJson(ref reader, options);
          break;

        case "valueExpression":
          ValueExpression = new fhirCsR4.Models.Expression();
          ValueExpression.DeserializeJson(ref reader, options);
          break;

        case "valueParameterDefinition":
          ValueParameterDefinition = new fhirCsR4.Models.ParameterDefinition();
          ValueParameterDefinition.DeserializeJson(ref reader, options);
          break;

        case "valueRelatedArtifact":
          ValueRelatedArtifact = new fhirCsR4.Models.RelatedArtifact();
          ValueRelatedArtifact.DeserializeJson(ref reader, options);
          break;

        case "valueTriggerDefinition":
          ValueTriggerDefinition = new fhirCsR4.Models.TriggerDefinition();
          ValueTriggerDefinition.DeserializeJson(ref reader, options);
          break;

        case "valueUsageContext":
          ValueUsageContext = new fhirCsR4.Models.UsageContext();
          ValueUsageContext.DeserializeJson(ref reader, options);
          break;

        case "valueDosage":
          ValueDosage = new fhirCsR4.Models.Dosage();
          ValueDosage.DeserializeJson(ref reader, options);
          break;

        case "valueMeta":
          ValueMeta = new fhirCsR4.Models.Meta();
          ValueMeta.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<ElementDefinitionConstraint>))]
  public class ElementDefinitionConstraint : Element,  IFhirJsonSerializable {
    /// <summary>
    /// In the absense of an expression, the expression is likely not enforceable by validators, and might be missed by many systems.
    /// </summary>
    public string Expression { get; set; }
    /// <summary>
    /// Extension container element for Expression
    /// </summary>
    public Element _Expression { get; set; }
    /// <summary>
    /// Should be expressed in business terms as much as possible.
    /// </summary>
    public string Human { get; set; }
    /// <summary>
    /// Extension container element for Human
    /// </summary>
    public Element _Human { get; set; }
    /// <summary>
    /// Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    /// </summary>
    public string Key { get; set; }
    /// <summary>
    /// Extension container element for Key
    /// </summary>
    public Element _Key { get; set; }
    /// <summary>
    /// To be used if the reason for the constraint might not be intuitive to all implementers.
    /// </summary>
    public string Requirements { get; set; }
    /// <summary>
    /// Extension container element for Requirements
    /// </summary>
    public Element _Requirements { get; set; }
    /// <summary>
    /// This allows constraints to be asserted as "shall" (error) and "should" (warning).
    /// </summary>
    public string Severity { get; set; }
    /// <summary>
    /// Extension container element for Severity
    /// </summary>
    public Element _Severity { get; set; }
    /// <summary>
    /// This is used when, e.g. rendering, where it is not useful to present inherited constraints when rendering the snapshot.
    /// </summary>
    public string Source { get; set; }
    /// <summary>
    /// Extension container element for Source
    /// </summary>
    public Element _Source { get; set; }
    /// <summary>
    /// Elements SHALL use "f" as the namespace prefix for the FHIR namespace, and "x" for the xhtml namespace, and SHALL NOT use any other prefixes.     Note: XPath is generally considered not useful because it does not apply to JSON and other formats and because of XSLT implementation issues, and may be removed in the future.
    /// </summary>
    public string Xpath { get; set; }
    /// <summary>
    /// Extension container element for Xpath
    /// </summary>
    public Element _Xpath { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Key))
      {
        writer.WriteString("key", (string)Key!);
      }

      if (_Key != null)
      {
        writer.WritePropertyName("_key");
        _Key.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Requirements))
      {
        writer.WriteString("requirements", (string)Requirements!);
      }

      if (_Requirements != null)
      {
        writer.WritePropertyName("_requirements");
        _Requirements.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Severity))
      {
        writer.WriteString("severity", (string)Severity!);
      }

      if (_Severity != null)
      {
        writer.WritePropertyName("_severity");
        _Severity.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Human))
      {
        writer.WriteString("human", (string)Human!);
      }

      if (_Human != null)
      {
        writer.WritePropertyName("_human");
        _Human.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Expression))
      {
        writer.WriteString("expression", (string)Expression!);
      }

      if (_Expression != null)
      {
        writer.WritePropertyName("_expression");
        _Expression.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Xpath))
      {
        writer.WriteString("xpath", (string)Xpath!);
      }

      if (_Xpath != null)
      {
        writer.WritePropertyName("_xpath");
        _Xpath.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Source))
      {
        writer.WriteString("source", (string)Source!);
      }

      if (_Source != null)
      {
        writer.WritePropertyName("_source");
        _Source.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "expression":
          Expression = reader.GetString();
          break;

        case "_expression":
          _Expression = new fhirCsR4.Models.Element();
          _Expression.DeserializeJson(ref reader, options);
          break;

        case "human":
          Human = reader.GetString();
          break;

        case "_human":
          _Human = new fhirCsR4.Models.Element();
          _Human.DeserializeJson(ref reader, options);
          break;

        case "key":
          Key = reader.GetString();
          break;

        case "_key":
          _Key = new fhirCsR4.Models.Element();
          _Key.DeserializeJson(ref reader, options);
          break;

        case "requirements":
          Requirements = reader.GetString();
          break;

        case "_requirements":
          _Requirements = new fhirCsR4.Models.Element();
          _Requirements.DeserializeJson(ref reader, options);
          break;

        case "severity":
          Severity = reader.GetString();
          break;

        case "_severity":
          _Severity = new fhirCsR4.Models.Element();
          _Severity.DeserializeJson(ref reader, options);
          break;

        case "source":
          Source = reader.GetString();
          break;

        case "_source":
          _Source = new fhirCsR4.Models.Element();
          _Source.DeserializeJson(ref reader, options);
          break;

        case "xpath":
          Xpath = reader.GetString();
          break;

        case "_xpath":
          _Xpath = new fhirCsR4.Models.Element();
          _Xpath.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ElementDefinition.constraint.severity field
  /// </summary>
  public static class ElementDefinitionConstraintSeverityCodes {
    public const string ERROR = "error";
    public const string WARNING = "warning";
  }
  /// <summary>
  /// For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<ElementDefinitionBinding>))]
  public class ElementDefinitionBinding : Element,  IFhirJsonSerializable {
    /// <summary>
    /// Describes the intended use of this particular set of codes.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// For further discussion, see [Using Terminologies](terminologies.html).
    /// </summary>
    public string Strength { get; set; }
    /// <summary>
    /// Extension container element for Strength
    /// </summary>
    public Element _Strength { get; set; }
    /// <summary>
    /// The reference may be version-specific or not (e.g. have a |[version] at the end of the canonical URL).
    /// </summary>
    public string ValueSet { get; set; }
    /// <summary>
    /// Extension container element for ValueSet
    /// </summary>
    public Element _ValueSet { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Strength))
      {
        writer.WriteString("strength", (string)Strength!);
      }

      if (_Strength != null)
      {
        writer.WritePropertyName("_strength");
        _Strength.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueSet))
      {
        writer.WriteString("valueSet", (string)ValueSet!);
      }

      if (_ValueSet != null)
      {
        writer.WritePropertyName("_valueSet");
        _ValueSet.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR4.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "strength":
          Strength = reader.GetString();
          break;

        case "_strength":
          _Strength = new fhirCsR4.Models.Element();
          _Strength.DeserializeJson(ref reader, options);
          break;

        case "valueSet":
          ValueSet = reader.GetString();
          break;

        case "_valueSet":
          _ValueSet = new fhirCsR4.Models.Element();
          _ValueSet.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ElementDefinition.binding.strength field
  /// </summary>
  public static class ElementDefinitionBindingStrengthCodes {
    public const string REQUIRED = "required";
    public const string EXTENSIBLE = "extensible";
    public const string PREFERRED = "preferred";
    public const string EXAMPLE = "example";
  }
  /// <summary>
  /// Mappings are not necessarily specific enough for safe translation.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<ElementDefinitionMapping>))]
  public class ElementDefinitionMapping : Element,  IFhirJsonSerializable {
    /// <summary>
    /// Comments that provide information about the mapping or its use.
    /// </summary>
    public string Comment { get; set; }
    /// <summary>
    /// Extension container element for Comment
    /// </summary>
    public Element _Comment { get; set; }
    /// <summary>
    /// An internal reference to the definition of a mapping.
    /// </summary>
    public string Identity { get; set; }
    /// <summary>
    /// Extension container element for Identity
    /// </summary>
    public Element _Identity { get; set; }
    /// <summary>
    /// If omitted, then there can be no expectation of computational interpretation of the mapping.
    /// </summary>
    public string Language { get; set; }
    /// <summary>
    /// Extension container element for Language
    /// </summary>
    public Element _Language { get; set; }
    /// <summary>
    /// For most mappings, the syntax is undefined.  Syntax will be provided for mappings to the RIM.  Multiple mappings may be possible and may include constraints on other resource elements that identify when a particular mapping applies.
    /// </summary>
    public string Map { get; set; }
    /// <summary>
    /// Extension container element for Map
    /// </summary>
    public Element _Map { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.Element)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Identity))
      {
        writer.WriteString("identity", (string)Identity!);
      }

      if (_Identity != null)
      {
        writer.WritePropertyName("_identity");
        _Identity.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Language))
      {
        writer.WriteString("language", (string)Language!);
      }

      if (_Language != null)
      {
        writer.WritePropertyName("_language");
        _Language.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Map))
      {
        writer.WriteString("map", (string)Map!);
      }

      if (_Map != null)
      {
        writer.WritePropertyName("_map");
        _Map.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Comment))
      {
        writer.WriteString("comment", (string)Comment!);
      }

      if (_Comment != null)
      {
        writer.WritePropertyName("_comment");
        _Comment.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "comment":
          Comment = reader.GetString();
          break;

        case "_comment":
          _Comment = new fhirCsR4.Models.Element();
          _Comment.DeserializeJson(ref reader, options);
          break;

        case "identity":
          Identity = reader.GetString();
          break;

        case "_identity":
          _Identity = new fhirCsR4.Models.Element();
          _Identity.DeserializeJson(ref reader, options);
          break;

        case "language":
          Language = reader.GetString();
          break;

        case "_language":
          _Language = new fhirCsR4.Models.Element();
          _Language.DeserializeJson(ref reader, options);
          break;

        case "map":
          Map = reader.GetString();
          break;

        case "_map":
          _Map = new fhirCsR4.Models.Element();
          _Map.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.Element)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Captures constraints on each element within the resource, profile, or extension.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<ElementDefinition>))]
  public class ElementDefinition : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Identifies additional names by which this element might also be known.
    /// </summary>
    public List<string> Alias { get; set; }
    /// <summary>
    /// Extension container element for Alias
    /// </summary>
    public List<Element> _Alias { get; set; }
    /// <summary>
    /// The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. For tooling simplicity, the base information must always be populated in element definitions in snap shots, even if it is the same.
    /// </summary>
    public ElementDefinitionBase Base { get; set; }
    /// <summary>
    /// For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
    /// </summary>
    public ElementDefinitionBinding Binding { get; set; }
    /// <summary>
    /// The concept SHALL be properly aligned with the data element definition and other constraints, as defined in the code system, including relationships, of any code listed here.  Where multiple codes exist in a terminology that could correspond to the data element, the most granular code(s) should be selected, so long as they are not more restrictive than the data element itself. The mappings may be used to provide more or less granular or structured equivalences in the code system.
    /// </summary>
    public List<Coding> Code { get; set; }
    /// <summary>
    /// If it is possible to capture usage rules using constraints, that mechanism should be used in preference to this element.
    /// </summary>
    public string Comment { get; set; }
    /// <summary>
    /// Extension container element for Comment
    /// </summary>
    public Element _Comment { get; set; }
    /// <summary>
    /// A reference to an invariant that may make additional statements about the cardinality or value in the instance.
    /// </summary>
    public List<string> Condition { get; set; }
    /// <summary>
    /// Extension container element for Condition
    /// </summary>
    public List<Element> _Condition { get; set; }
    /// <summary>
    /// Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
    /// </summary>
    public List<ElementDefinitionConstraint> Constraint { get; set; }
    /// <summary>
    /// ContentReferences can only be defined in specializations, not constrained types, and they cannot be changed and always reference the non-constrained definition.
    /// </summary>
    public string ContentReference { get; set; }
    /// <summary>
    /// Extension container element for ContentReference
    /// </summary>
    public Element _ContentReference { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public byte[] DefaultValueBase64Binary { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public bool? DefaultValueBoolean { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueCanonical { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueCanonical
    /// </summary>
    public Element _DefaultValueCanonical { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueCode { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueCode
    /// </summary>
    public Element _DefaultValueCode { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueDate { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueDate
    /// </summary>
    public Element _DefaultValueDate { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueDateTime
    /// </summary>
    public Element _DefaultValueDateTime { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public decimal? DefaultValueDecimal { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueDecimal
    /// </summary>
    public Element _DefaultValueDecimal { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueId { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueId
    /// </summary>
    public Element _DefaultValueId { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueInstant { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueInstant
    /// </summary>
    public Element _DefaultValueInstant { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public int? DefaultValueInteger { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueMarkdown { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueMarkdown
    /// </summary>
    public Element _DefaultValueMarkdown { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueOid { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueOid
    /// </summary>
    public Element _DefaultValueOid { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public uint? DefaultValuePositiveInt { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueString { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueString
    /// </summary>
    public Element _DefaultValueString { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueTime { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueTime
    /// </summary>
    public Element _DefaultValueTime { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public uint? DefaultValueUnsignedInt { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueUri { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueUri
    /// </summary>
    public Element _DefaultValueUri { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public string DefaultValueUrl { get; set; }
    /// <summary>
    /// Extension container element for DefaultValueUrl
    /// </summary>
    public Element _DefaultValueUrl { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Guid? DefaultValueUuid { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Address DefaultValueAddress { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Age DefaultValueAge { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Annotation DefaultValueAnnotation { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Attachment DefaultValueAttachment { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public CodeableConcept DefaultValueCodeableConcept { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Coding DefaultValueCoding { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public ContactPoint DefaultValueContactPoint { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Count DefaultValueCount { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Distance DefaultValueDistance { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Duration DefaultValueDuration { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public HumanName DefaultValueHumanName { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Identifier DefaultValueIdentifier { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Money DefaultValueMoney { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Period DefaultValuePeriod { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Quantity DefaultValueQuantity { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Range DefaultValueRange { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Ratio DefaultValueRatio { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Reference DefaultValueReference { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public SampledData DefaultValueSampledData { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Signature DefaultValueSignature { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Timing DefaultValueTiming { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public ContactDetail DefaultValueContactDetail { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Contributor DefaultValueContributor { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public DataRequirement DefaultValueDataRequirement { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Expression DefaultValueExpression { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public ParameterDefinition DefaultValueParameterDefinition { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public RelatedArtifact DefaultValueRelatedArtifact { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public TriggerDefinition DefaultValueTriggerDefinition { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public UsageContext DefaultValueUsageContext { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Dosage DefaultValueDosage { get; set; }
    /// <summary>
    /// Specifying a default value means that the property can never been unknown - it must always have a value. Further, the default value can never be changed, or changed in constraints on content models. Defining default values creates many difficulties in implementation (e.g. when is a value missing?). For these reasons, default values are (and should be) used extremely sparingly. 
    /// No default values are ever defined in the FHIR specification, nor can they be defined in constraints ("profiles") on data types or resources. This element only exists so that default values may be defined in logical models.
    /// </summary>
    public Meta DefaultValueMeta { get; set; }
    /// <summary>
    /// It is easy for a different definition to change the meaning of an element and this can have nasty downstream consequences. Please be careful when providing definitions in a profile.
    /// </summary>
    public string Definition { get; set; }
    /// <summary>
    /// Extension container element for Definition
    /// </summary>
    public Element _Definition { get; set; }
    /// <summary>
    /// Examples will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
    /// </summary>
    public List<ElementDefinitionExample> Example { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public byte[] FixedBase64Binary { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public bool? FixedBoolean { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedCanonical { get; set; }
    /// <summary>
    /// Extension container element for FixedCanonical
    /// </summary>
    public Element _FixedCanonical { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedCode { get; set; }
    /// <summary>
    /// Extension container element for FixedCode
    /// </summary>
    public Element _FixedCode { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedDate { get; set; }
    /// <summary>
    /// Extension container element for FixedDate
    /// </summary>
    public Element _FixedDate { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedDateTime { get; set; }
    /// <summary>
    /// Extension container element for FixedDateTime
    /// </summary>
    public Element _FixedDateTime { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public decimal? FixedDecimal { get; set; }
    /// <summary>
    /// Extension container element for FixedDecimal
    /// </summary>
    public Element _FixedDecimal { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedId { get; set; }
    /// <summary>
    /// Extension container element for FixedId
    /// </summary>
    public Element _FixedId { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedInstant { get; set; }
    /// <summary>
    /// Extension container element for FixedInstant
    /// </summary>
    public Element _FixedInstant { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public int? FixedInteger { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedMarkdown { get; set; }
    /// <summary>
    /// Extension container element for FixedMarkdown
    /// </summary>
    public Element _FixedMarkdown { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedOid { get; set; }
    /// <summary>
    /// Extension container element for FixedOid
    /// </summary>
    public Element _FixedOid { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public uint? FixedPositiveInt { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedString { get; set; }
    /// <summary>
    /// Extension container element for FixedString
    /// </summary>
    public Element _FixedString { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedTime { get; set; }
    /// <summary>
    /// Extension container element for FixedTime
    /// </summary>
    public Element _FixedTime { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public uint? FixedUnsignedInt { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedUri { get; set; }
    /// <summary>
    /// Extension container element for FixedUri
    /// </summary>
    public Element _FixedUri { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public string FixedUrl { get; set; }
    /// <summary>
    /// Extension container element for FixedUrl
    /// </summary>
    public Element _FixedUrl { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Guid? FixedUuid { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Address FixedAddress { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Age FixedAge { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Annotation FixedAnnotation { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Attachment FixedAttachment { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public CodeableConcept FixedCodeableConcept { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Coding FixedCoding { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public ContactPoint FixedContactPoint { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Count FixedCount { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Distance FixedDistance { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Duration FixedDuration { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public HumanName FixedHumanName { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Identifier FixedIdentifier { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Money FixedMoney { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Period FixedPeriod { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Quantity FixedQuantity { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Range FixedRange { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Ratio FixedRatio { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Reference FixedReference { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public SampledData FixedSampledData { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Signature FixedSignature { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Timing FixedTiming { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public ContactDetail FixedContactDetail { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Contributor FixedContributor { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public DataRequirement FixedDataRequirement { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Expression FixedExpression { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public ParameterDefinition FixedParameterDefinition { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public RelatedArtifact FixedRelatedArtifact { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public TriggerDefinition FixedTriggerDefinition { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public UsageContext FixedUsageContext { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Dosage FixedDosage { get; set; }
    /// <summary>
    /// This is not recommended for Coding and CodeableConcept since these often have highly contextual properties such as version or display.
    /// </summary>
    public Meta FixedMeta { get; set; }
    /// <summary>
    /// Only the definition of an element can set IsModifier true - either the specification itself or where an extension is originally defined. Once set, it cannot be changed in derived profiles. An element/extension that has isModifier=true SHOULD also have a minimum cardinality of 1, so that there is no lack of clarity about what to do if it is missing. If it can be missing, the definition SHALL make the meaning of a missing element clear.
    /// </summary>
    public bool? IsModifier { get; set; }
    /// <summary>
    /// Explains how that element affects the interpretation of the resource or element that contains it.
    /// </summary>
    public string IsModifierReason { get; set; }
    /// <summary>
    /// Extension container element for IsModifierReason
    /// </summary>
    public Element _IsModifierReason { get; set; }
    /// <summary>
    /// Some resources include a set of simple metadata, and some very large data. This element is used to reduce the quantity of data returned in searches. Note that servers may pre-cache summarized resources for optimal performance, so servers might not support per-profile use of the isSummary flag. When a request is made with _summary=true, serailisers only include elements marked as 'isSummary = true'. Other than Attachment.data, all data type properties are included in the summary form. In resource and data type definitions, if an element is at the root or has a parent that is 'mustSupport' and the minimum cardinality is 1 or the element is a modifier, it must be marked as isSummary=true.
    /// </summary>
    public bool? IsSummary { get; set; }
    /// <summary>
    /// See also the extension (http://hl7.org/fhir/StructureDefinition/elementdefinition-question)[extension-elementdefinition-question.html].
    /// </summary>
    public string Label { get; set; }
    /// <summary>
    /// Extension container element for Label
    /// </summary>
    public Element _Label { get; set; }
    /// <summary>
    /// Mappings are not necessarily specific enough for safe translation.
    /// </summary>
    public List<ElementDefinitionMapping> Mapping { get; set; }
    /// <summary>
    /// The maximum number of times this element is permitted to appear in the instance.
    /// </summary>
    public string Max { get; set; }
    /// <summary>
    /// Extension container element for Max
    /// </summary>
    public Element _Max { get; set; }
    /// <summary>
    /// Receivers are not required to reject instances that exceed the maximum length.  The full length could be stored.  In some cases, data might be truncated, though truncation should be undertaken with care and an understanding of the consequences of doing so. If not specified, there is no conformance expectation for length support.
    /// </summary>
    public int? MaxLength { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
    /// </summary>
    public string MaxValueDate { get; set; }
    /// <summary>
    /// Extension container element for MaxValueDate
    /// </summary>
    public Element _MaxValueDate { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
    /// </summary>
    public string MaxValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for MaxValueDateTime
    /// </summary>
    public Element _MaxValueDateTime { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
    /// </summary>
    public string MaxValueInstant { get; set; }
    /// <summary>
    /// Extension container element for MaxValueInstant
    /// </summary>
    public Element _MaxValueInstant { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
    /// </summary>
    public string MaxValueTime { get; set; }
    /// <summary>
    /// Extension container element for MaxValueTime
    /// </summary>
    public Element _MaxValueTime { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
    /// </summary>
    public decimal? MaxValueDecimal { get; set; }
    /// <summary>
    /// Extension container element for MaxValueDecimal
    /// </summary>
    public Element _MaxValueDecimal { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
    /// </summary>
    public int? MaxValueInteger { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
    /// </summary>
    public uint? MaxValuePositiveInt { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
    /// </summary>
    public uint? MaxValueUnsignedInt { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the maxValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of maxValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is added to the current clock to determine the maximum allowable value.   A maximum value for a Quantity is interpreted as an canonical maximum - e.g. you cannot provide 10g if the maximum value is 50mg.
    /// </summary>
    public Quantity MaxValueQuantity { get; set; }
    /// <summary>
    /// Implicit meanings for missing values can only be specified on a resource, data type, or extension definition, and never in a profile that applies to one of these. An implicit meaning for a missing value can never be changed, and specifying one has the consequence that constraining its use in profiles eliminates use cases as possibilities, not merely moving them out of scope.
    /// </summary>
    public string MeaningWhenMissing { get; set; }
    /// <summary>
    /// Extension container element for MeaningWhenMissing
    /// </summary>
    public Element _MeaningWhenMissing { get; set; }
    /// <summary>
    /// The minimum number of times this element SHALL appear in the instance.
    /// </summary>
    public uint? Min { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
    /// </summary>
    public string MinValueDate { get; set; }
    /// <summary>
    /// Extension container element for MinValueDate
    /// </summary>
    public Element _MinValueDate { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
    /// </summary>
    public string MinValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for MinValueDateTime
    /// </summary>
    public Element _MinValueDateTime { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
    /// </summary>
    public string MinValueInstant { get; set; }
    /// <summary>
    /// Extension container element for MinValueInstant
    /// </summary>
    public Element _MinValueInstant { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
    /// </summary>
    public string MinValueTime { get; set; }
    /// <summary>
    /// Extension container element for MinValueTime
    /// </summary>
    public Element _MinValueTime { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
    /// </summary>
    public decimal? MinValueDecimal { get; set; }
    /// <summary>
    /// Extension container element for MinValueDecimal
    /// </summary>
    public Element _MinValueDecimal { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
    /// </summary>
    public int? MinValueInteger { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
    /// </summary>
    public uint? MinValuePositiveInt { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
    /// </summary>
    public uint? MinValueUnsignedInt { get; set; }
    /// <summary>
    /// Except for date/date/instant, the type of the minValue[x] SHALL be the same as the specified type of the element. For the date/dateTime/instant values, the type of minValue[x] SHALL be either the same, or a [Duration](datatypes.html#Duration) which specifies a relative time limit to the current time. The duration value is positive, and is subtracted from the current clock to determine the minimum allowable value.   A minimum value for a Quantity is interpreted as an canonical minimum - e.g. you cannot provide 100mg if the minimum value is 10g.
    /// </summary>
    public Quantity MinValueQuantity { get; set; }
    /// <summary>
    /// "Something useful" is context dependent and impossible to describe in the base FHIR specification. For this reason, tue mustSupport flag is never set to true by the FHIR specification itself - it is only set to true in profiles.  A profile on a type can always make musSupport = true if it is false in the base type but cannot make mustSupport = false if it is true in the base type.   This is done in [Resource Profiles](profiling.html#mustsupport), where the profile labels an element as mustSupport=true. When a profile does this, it SHALL also make clear exactly what kind of "support" is required, as this can mean many things.    Note that an element that has the property IsModifier is not necessarily a "key" element (e.g. one of the important elements to make use of the resource), nor is it automatically mustSupport - however both of these things are more likely to be true for IsModifier elements than for other elements.
    /// </summary>
    public bool? MustSupport { get; set; }
    /// <summary>
    /// This element can only be asserted on repeating elements and can only be introduced when defining resources or data types.  It can be further refined profiled elements but if absent in the base type, a profile cannot assert meaning.
    /// </summary>
    public string OrderMeaning { get; set; }
    /// <summary>
    /// Extension container element for OrderMeaning
    /// </summary>
    public Element _OrderMeaning { get; set; }
    /// <summary>
    /// The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
    /// </summary>
    public string Path { get; set; }
    /// <summary>
    /// Extension container element for Path
    /// </summary>
    public Element _Path { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public byte[] PatternBase64Binary { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public bool? PatternBoolean { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternCanonical { get; set; }
    /// <summary>
    /// Extension container element for PatternCanonical
    /// </summary>
    public Element _PatternCanonical { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternCode { get; set; }
    /// <summary>
    /// Extension container element for PatternCode
    /// </summary>
    public Element _PatternCode { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternDate { get; set; }
    /// <summary>
    /// Extension container element for PatternDate
    /// </summary>
    public Element _PatternDate { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternDateTime { get; set; }
    /// <summary>
    /// Extension container element for PatternDateTime
    /// </summary>
    public Element _PatternDateTime { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public decimal? PatternDecimal { get; set; }
    /// <summary>
    /// Extension container element for PatternDecimal
    /// </summary>
    public Element _PatternDecimal { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternId { get; set; }
    /// <summary>
    /// Extension container element for PatternId
    /// </summary>
    public Element _PatternId { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternInstant { get; set; }
    /// <summary>
    /// Extension container element for PatternInstant
    /// </summary>
    public Element _PatternInstant { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public int? PatternInteger { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternMarkdown { get; set; }
    /// <summary>
    /// Extension container element for PatternMarkdown
    /// </summary>
    public Element _PatternMarkdown { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternOid { get; set; }
    /// <summary>
    /// Extension container element for PatternOid
    /// </summary>
    public Element _PatternOid { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public uint? PatternPositiveInt { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternString { get; set; }
    /// <summary>
    /// Extension container element for PatternString
    /// </summary>
    public Element _PatternString { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternTime { get; set; }
    /// <summary>
    /// Extension container element for PatternTime
    /// </summary>
    public Element _PatternTime { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public uint? PatternUnsignedInt { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternUri { get; set; }
    /// <summary>
    /// Extension container element for PatternUri
    /// </summary>
    public Element _PatternUri { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public string PatternUrl { get; set; }
    /// <summary>
    /// Extension container element for PatternUrl
    /// </summary>
    public Element _PatternUrl { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Guid? PatternUuid { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Address PatternAddress { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Age PatternAge { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Annotation PatternAnnotation { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Attachment PatternAttachment { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public CodeableConcept PatternCodeableConcept { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Coding PatternCoding { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public ContactPoint PatternContactPoint { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Count PatternCount { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Distance PatternDistance { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Duration PatternDuration { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public HumanName PatternHumanName { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Identifier PatternIdentifier { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Money PatternMoney { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Period PatternPeriod { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Quantity PatternQuantity { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Range PatternRange { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Ratio PatternRatio { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Reference PatternReference { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public SampledData PatternSampledData { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Signature PatternSignature { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Timing PatternTiming { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public ContactDetail PatternContactDetail { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Contributor PatternContributor { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public DataRequirement PatternDataRequirement { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Expression PatternExpression { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public ParameterDefinition PatternParameterDefinition { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public RelatedArtifact PatternRelatedArtifact { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public TriggerDefinition PatternTriggerDefinition { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public UsageContext PatternUsageContext { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Dosage PatternDosage { get; set; }
    /// <summary>
    /// Mostly used for fixing values of CodeableConcept. In general, pattern[x] is not intended for use with primitive types, where is has the same meaning as fixed[x].
    /// </summary>
    public Meta PatternMeta { get; set; }
    /// <summary>
    /// In resources, this is rarely used except for special cases where the representation deviates from the normal, and can only be done in the base standard (and profiles must reproduce what the base standard does). This element is used quite commonly in Logical models when the logical models represent a specific serialization format (e.g. CDA, v2 etc.).
    /// </summary>
    public List<string> Representation { get; set; }
    /// <summary>
    /// Extension container element for Representation
    /// </summary>
    public List<Element> _Representation { get; set; }
    /// <summary>
    /// This element does not describe the usage of the element (that's done in comments), rather it's for traceability of *why* the element is either needed or why the constraints exist as they do.  This may be used to point to source materials or specifications that drove the structure of this data element.
    /// </summary>
    public string Requirements { get; set; }
    /// <summary>
    /// Extension container element for Requirements
    /// </summary>
    public Element _Requirements { get; set; }
    /// <summary>
    /// It is easy for a different short definition to change the meaning of an element and this can have nasty downstream consequences. Please be careful when providing short definitions in a profile.
    /// </summary>
    public string Short { get; set; }
    /// <summary>
    /// Extension container element for Short
    /// </summary>
    public Element _Short { get; set; }
    /// <summary>
    /// If set to true, an ancestor profile SHALL have a slicing definition with this name.  If set to false, no ancestor profile is permitted to have a slicing definition with this name.
    /// </summary>
    public bool? SliceIsConstraining { get; set; }
    /// <summary>
    /// The name SHALL be unique within the structure within the context of the constrained resource element.  (Though to avoid confusion, uniqueness across all elements is recommended.).
    /// </summary>
    public string SliceName { get; set; }
    /// <summary>
    /// Extension container element for SliceName
    /// </summary>
    public Element _SliceName { get; set; }
    /// <summary>
    /// The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
    /// </summary>
    public ElementDefinitionSlicing Slicing { get; set; }
    /// <summary>
    /// The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
    /// </summary>
    public List<ElementDefinitionType> Type { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Path))
      {
        writer.WriteString("path", (string)Path!);
      }

      if (_Path != null)
      {
        writer.WritePropertyName("_path");
        _Path.SerializeJson(writer, options);
      }

      if ((Representation != null) && (Representation.Count != 0))
      {
        writer.WritePropertyName("representation");
        writer.WriteStartArray();

        foreach (string valRepresentation in Representation)
        {
          writer.WriteStringValue(valRepresentation);
        }

        writer.WriteEndArray();
      }

      if ((_Representation != null) && (_Representation.Count != 0))
      {
        writer.WritePropertyName("_representation");
        writer.WriteStartArray();

        foreach (Element val_Representation in _Representation)
        {
          val_Representation.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(SliceName))
      {
        writer.WriteString("sliceName", (string)SliceName!);
      }

      if (_SliceName != null)
      {
        writer.WritePropertyName("_sliceName");
        _SliceName.SerializeJson(writer, options);
      }

      if (SliceIsConstraining != null)
      {
        writer.WriteBoolean("sliceIsConstraining", (bool)SliceIsConstraining!);
      }

      if (!string.IsNullOrEmpty(Label))
      {
        writer.WriteString("label", (string)Label!);
      }

      if (_Label != null)
      {
        writer.WritePropertyName("_label");
        _Label.SerializeJson(writer, options);
      }

      if ((Code != null) && (Code.Count != 0))
      {
        writer.WritePropertyName("code");
        writer.WriteStartArray();

        foreach (Coding valCode in Code)
        {
          valCode.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Slicing != null)
      {
        writer.WritePropertyName("slicing");
        Slicing.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Short))
      {
        writer.WriteString("short", (string)Short!);
      }

      if (_Short != null)
      {
        writer.WritePropertyName("_short");
        _Short.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Definition))
      {
        writer.WriteString("definition", (string)Definition!);
      }

      if (_Definition != null)
      {
        writer.WritePropertyName("_definition");
        _Definition.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Comment))
      {
        writer.WriteString("comment", (string)Comment!);
      }

      if (_Comment != null)
      {
        writer.WritePropertyName("_comment");
        _Comment.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Requirements))
      {
        writer.WriteString("requirements", (string)Requirements!);
      }

      if (_Requirements != null)
      {
        writer.WritePropertyName("_requirements");
        _Requirements.SerializeJson(writer, options);
      }

      if ((Alias != null) && (Alias.Count != 0))
      {
        writer.WritePropertyName("alias");
        writer.WriteStartArray();

        foreach (string valAlias in Alias)
        {
          writer.WriteStringValue(valAlias);
        }

        writer.WriteEndArray();
      }

      if ((_Alias != null) && (_Alias.Count != 0))
      {
        writer.WritePropertyName("_alias");
        writer.WriteStartArray();

        foreach (Element val_Alias in _Alias)
        {
          val_Alias.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Min != null)
      {
        writer.WriteNumber("min", (uint)Min!);
      }

      if (!string.IsNullOrEmpty(Max))
      {
        writer.WriteString("max", (string)Max!);
      }

      if (_Max != null)
      {
        writer.WritePropertyName("_max");
        _Max.SerializeJson(writer, options);
      }

      if (Base != null)
      {
        writer.WritePropertyName("base");
        Base.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ContentReference))
      {
        writer.WriteString("contentReference", (string)ContentReference!);
      }

      if (_ContentReference != null)
      {
        writer.WritePropertyName("_contentReference");
        _ContentReference.SerializeJson(writer, options);
      }

      if ((Type != null) && (Type.Count != 0))
      {
        writer.WritePropertyName("type");
        writer.WriteStartArray();

        foreach (ElementDefinitionType valType in Type)
        {
          valType.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (DefaultValueBase64Binary != null)
      {
        writer.WriteString("defaultValueBase64Binary", System.Convert.ToBase64String(DefaultValueBase64Binary));
      }

      if (DefaultValueBoolean != null)
      {
        writer.WriteBoolean("defaultValueBoolean", (bool)DefaultValueBoolean!);
      }

      if (!string.IsNullOrEmpty(DefaultValueCanonical))
      {
        writer.WriteString("defaultValueCanonical", (string)DefaultValueCanonical!);
      }

      if (_DefaultValueCanonical != null)
      {
        writer.WritePropertyName("_defaultValueCanonical");
        _DefaultValueCanonical.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueCode))
      {
        writer.WriteString("defaultValueCode", (string)DefaultValueCode!);
      }

      if (_DefaultValueCode != null)
      {
        writer.WritePropertyName("_defaultValueCode");
        _DefaultValueCode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueDate))
      {
        writer.WriteString("defaultValueDate", (string)DefaultValueDate!);
      }

      if (_DefaultValueDate != null)
      {
        writer.WritePropertyName("_defaultValueDate");
        _DefaultValueDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueDateTime))
      {
        writer.WriteString("defaultValueDateTime", (string)DefaultValueDateTime!);
      }

      if (_DefaultValueDateTime != null)
      {
        writer.WritePropertyName("_defaultValueDateTime");
        _DefaultValueDateTime.SerializeJson(writer, options);
      }

      if (DefaultValueDecimal != null)
      {
        writer.WriteNumber("defaultValueDecimal", (decimal)DefaultValueDecimal!);
      }

      if (_DefaultValueDecimal != null)
      {
        writer.WritePropertyName("_defaultValueDecimal");
        _DefaultValueDecimal.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueId))
      {
        writer.WriteString("defaultValueId", (string)DefaultValueId!);
      }

      if (_DefaultValueId != null)
      {
        writer.WritePropertyName("_defaultValueId");
        _DefaultValueId.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueInstant))
      {
        writer.WriteString("defaultValueInstant", (string)DefaultValueInstant!);
      }

      if (_DefaultValueInstant != null)
      {
        writer.WritePropertyName("_defaultValueInstant");
        _DefaultValueInstant.SerializeJson(writer, options);
      }

      if (DefaultValueInteger != null)
      {
        writer.WriteNumber("defaultValueInteger", (int)DefaultValueInteger!);
      }

      if (!string.IsNullOrEmpty(DefaultValueMarkdown))
      {
        writer.WriteString("defaultValueMarkdown", (string)DefaultValueMarkdown!);
      }

      if (_DefaultValueMarkdown != null)
      {
        writer.WritePropertyName("_defaultValueMarkdown");
        _DefaultValueMarkdown.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueOid))
      {
        writer.WriteString("defaultValueOid", (string)DefaultValueOid!);
      }

      if (_DefaultValueOid != null)
      {
        writer.WritePropertyName("_defaultValueOid");
        _DefaultValueOid.SerializeJson(writer, options);
      }

      if (DefaultValuePositiveInt != null)
      {
        writer.WriteNumber("defaultValuePositiveInt", (uint)DefaultValuePositiveInt!);
      }

      if (!string.IsNullOrEmpty(DefaultValueString))
      {
        writer.WriteString("defaultValueString", (string)DefaultValueString!);
      }

      if (_DefaultValueString != null)
      {
        writer.WritePropertyName("_defaultValueString");
        _DefaultValueString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueTime))
      {
        writer.WriteString("defaultValueTime", (string)DefaultValueTime!);
      }

      if (_DefaultValueTime != null)
      {
        writer.WritePropertyName("_defaultValueTime");
        _DefaultValueTime.SerializeJson(writer, options);
      }

      if (DefaultValueUnsignedInt != null)
      {
        writer.WriteNumber("defaultValueUnsignedInt", (uint)DefaultValueUnsignedInt!);
      }

      if (!string.IsNullOrEmpty(DefaultValueUri))
      {
        writer.WriteString("defaultValueUri", (string)DefaultValueUri!);
      }

      if (_DefaultValueUri != null)
      {
        writer.WritePropertyName("_defaultValueUri");
        _DefaultValueUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefaultValueUrl))
      {
        writer.WriteString("defaultValueUrl", (string)DefaultValueUrl!);
      }

      if (_DefaultValueUrl != null)
      {
        writer.WritePropertyName("_defaultValueUrl");
        _DefaultValueUrl.SerializeJson(writer, options);
      }

      if (DefaultValueUuid != null)
      {
        writer.WriteString("defaultValueUuid", (Guid)DefaultValueUuid!);
      }

      if (DefaultValueAddress != null)
      {
        writer.WritePropertyName("defaultValueAddress");
        DefaultValueAddress.SerializeJson(writer, options);
      }

      if (DefaultValueAge != null)
      {
        writer.WritePropertyName("defaultValueAge");
        DefaultValueAge.SerializeJson(writer, options);
      }

      if (DefaultValueAnnotation != null)
      {
        writer.WritePropertyName("defaultValueAnnotation");
        DefaultValueAnnotation.SerializeJson(writer, options);
      }

      if (DefaultValueAttachment != null)
      {
        writer.WritePropertyName("defaultValueAttachment");
        DefaultValueAttachment.SerializeJson(writer, options);
      }

      if (DefaultValueCodeableConcept != null)
      {
        writer.WritePropertyName("defaultValueCodeableConcept");
        DefaultValueCodeableConcept.SerializeJson(writer, options);
      }

      if (DefaultValueCoding != null)
      {
        writer.WritePropertyName("defaultValueCoding");
        DefaultValueCoding.SerializeJson(writer, options);
      }

      if (DefaultValueContactPoint != null)
      {
        writer.WritePropertyName("defaultValueContactPoint");
        DefaultValueContactPoint.SerializeJson(writer, options);
      }

      if (DefaultValueCount != null)
      {
        writer.WritePropertyName("defaultValueCount");
        DefaultValueCount.SerializeJson(writer, options);
      }

      if (DefaultValueDistance != null)
      {
        writer.WritePropertyName("defaultValueDistance");
        DefaultValueDistance.SerializeJson(writer, options);
      }

      if (DefaultValueDuration != null)
      {
        writer.WritePropertyName("defaultValueDuration");
        DefaultValueDuration.SerializeJson(writer, options);
      }

      if (DefaultValueHumanName != null)
      {
        writer.WritePropertyName("defaultValueHumanName");
        DefaultValueHumanName.SerializeJson(writer, options);
      }

      if (DefaultValueIdentifier != null)
      {
        writer.WritePropertyName("defaultValueIdentifier");
        DefaultValueIdentifier.SerializeJson(writer, options);
      }

      if (DefaultValueMoney != null)
      {
        writer.WritePropertyName("defaultValueMoney");
        DefaultValueMoney.SerializeJson(writer, options);
      }

      if (DefaultValuePeriod != null)
      {
        writer.WritePropertyName("defaultValuePeriod");
        DefaultValuePeriod.SerializeJson(writer, options);
      }

      if (DefaultValueQuantity != null)
      {
        writer.WritePropertyName("defaultValueQuantity");
        DefaultValueQuantity.SerializeJson(writer, options);
      }

      if (DefaultValueRange != null)
      {
        writer.WritePropertyName("defaultValueRange");
        DefaultValueRange.SerializeJson(writer, options);
      }

      if (DefaultValueRatio != null)
      {
        writer.WritePropertyName("defaultValueRatio");
        DefaultValueRatio.SerializeJson(writer, options);
      }

      if (DefaultValueReference != null)
      {
        writer.WritePropertyName("defaultValueReference");
        DefaultValueReference.SerializeJson(writer, options);
      }

      if (DefaultValueSampledData != null)
      {
        writer.WritePropertyName("defaultValueSampledData");
        DefaultValueSampledData.SerializeJson(writer, options);
      }

      if (DefaultValueSignature != null)
      {
        writer.WritePropertyName("defaultValueSignature");
        DefaultValueSignature.SerializeJson(writer, options);
      }

      if (DefaultValueTiming != null)
      {
        writer.WritePropertyName("defaultValueTiming");
        DefaultValueTiming.SerializeJson(writer, options);
      }

      if (DefaultValueContactDetail != null)
      {
        writer.WritePropertyName("defaultValueContactDetail");
        DefaultValueContactDetail.SerializeJson(writer, options);
      }

      if (DefaultValueContributor != null)
      {
        writer.WritePropertyName("defaultValueContributor");
        DefaultValueContributor.SerializeJson(writer, options);
      }

      if (DefaultValueDataRequirement != null)
      {
        writer.WritePropertyName("defaultValueDataRequirement");
        DefaultValueDataRequirement.SerializeJson(writer, options);
      }

      if (DefaultValueExpression != null)
      {
        writer.WritePropertyName("defaultValueExpression");
        DefaultValueExpression.SerializeJson(writer, options);
      }

      if (DefaultValueParameterDefinition != null)
      {
        writer.WritePropertyName("defaultValueParameterDefinition");
        DefaultValueParameterDefinition.SerializeJson(writer, options);
      }

      if (DefaultValueRelatedArtifact != null)
      {
        writer.WritePropertyName("defaultValueRelatedArtifact");
        DefaultValueRelatedArtifact.SerializeJson(writer, options);
      }

      if (DefaultValueTriggerDefinition != null)
      {
        writer.WritePropertyName("defaultValueTriggerDefinition");
        DefaultValueTriggerDefinition.SerializeJson(writer, options);
      }

      if (DefaultValueUsageContext != null)
      {
        writer.WritePropertyName("defaultValueUsageContext");
        DefaultValueUsageContext.SerializeJson(writer, options);
      }

      if (DefaultValueDosage != null)
      {
        writer.WritePropertyName("defaultValueDosage");
        DefaultValueDosage.SerializeJson(writer, options);
      }

      if (DefaultValueMeta != null)
      {
        writer.WritePropertyName("defaultValueMeta");
        DefaultValueMeta.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MeaningWhenMissing))
      {
        writer.WriteString("meaningWhenMissing", (string)MeaningWhenMissing!);
      }

      if (_MeaningWhenMissing != null)
      {
        writer.WritePropertyName("_meaningWhenMissing");
        _MeaningWhenMissing.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(OrderMeaning))
      {
        writer.WriteString("orderMeaning", (string)OrderMeaning!);
      }

      if (_OrderMeaning != null)
      {
        writer.WritePropertyName("_orderMeaning");
        _OrderMeaning.SerializeJson(writer, options);
      }

      if (FixedBase64Binary != null)
      {
        writer.WriteString("fixedBase64Binary", System.Convert.ToBase64String(FixedBase64Binary));
      }

      if (FixedBoolean != null)
      {
        writer.WriteBoolean("fixedBoolean", (bool)FixedBoolean!);
      }

      if (!string.IsNullOrEmpty(FixedCanonical))
      {
        writer.WriteString("fixedCanonical", (string)FixedCanonical!);
      }

      if (_FixedCanonical != null)
      {
        writer.WritePropertyName("_fixedCanonical");
        _FixedCanonical.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedCode))
      {
        writer.WriteString("fixedCode", (string)FixedCode!);
      }

      if (_FixedCode != null)
      {
        writer.WritePropertyName("_fixedCode");
        _FixedCode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedDate))
      {
        writer.WriteString("fixedDate", (string)FixedDate!);
      }

      if (_FixedDate != null)
      {
        writer.WritePropertyName("_fixedDate");
        _FixedDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedDateTime))
      {
        writer.WriteString("fixedDateTime", (string)FixedDateTime!);
      }

      if (_FixedDateTime != null)
      {
        writer.WritePropertyName("_fixedDateTime");
        _FixedDateTime.SerializeJson(writer, options);
      }

      if (FixedDecimal != null)
      {
        writer.WriteNumber("fixedDecimal", (decimal)FixedDecimal!);
      }

      if (_FixedDecimal != null)
      {
        writer.WritePropertyName("_fixedDecimal");
        _FixedDecimal.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedId))
      {
        writer.WriteString("fixedId", (string)FixedId!);
      }

      if (_FixedId != null)
      {
        writer.WritePropertyName("_fixedId");
        _FixedId.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedInstant))
      {
        writer.WriteString("fixedInstant", (string)FixedInstant!);
      }

      if (_FixedInstant != null)
      {
        writer.WritePropertyName("_fixedInstant");
        _FixedInstant.SerializeJson(writer, options);
      }

      if (FixedInteger != null)
      {
        writer.WriteNumber("fixedInteger", (int)FixedInteger!);
      }

      if (!string.IsNullOrEmpty(FixedMarkdown))
      {
        writer.WriteString("fixedMarkdown", (string)FixedMarkdown!);
      }

      if (_FixedMarkdown != null)
      {
        writer.WritePropertyName("_fixedMarkdown");
        _FixedMarkdown.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedOid))
      {
        writer.WriteString("fixedOid", (string)FixedOid!);
      }

      if (_FixedOid != null)
      {
        writer.WritePropertyName("_fixedOid");
        _FixedOid.SerializeJson(writer, options);
      }

      if (FixedPositiveInt != null)
      {
        writer.WriteNumber("fixedPositiveInt", (uint)FixedPositiveInt!);
      }

      if (!string.IsNullOrEmpty(FixedString))
      {
        writer.WriteString("fixedString", (string)FixedString!);
      }

      if (_FixedString != null)
      {
        writer.WritePropertyName("_fixedString");
        _FixedString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedTime))
      {
        writer.WriteString("fixedTime", (string)FixedTime!);
      }

      if (_FixedTime != null)
      {
        writer.WritePropertyName("_fixedTime");
        _FixedTime.SerializeJson(writer, options);
      }

      if (FixedUnsignedInt != null)
      {
        writer.WriteNumber("fixedUnsignedInt", (uint)FixedUnsignedInt!);
      }

      if (!string.IsNullOrEmpty(FixedUri))
      {
        writer.WriteString("fixedUri", (string)FixedUri!);
      }

      if (_FixedUri != null)
      {
        writer.WritePropertyName("_fixedUri");
        _FixedUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(FixedUrl))
      {
        writer.WriteString("fixedUrl", (string)FixedUrl!);
      }

      if (_FixedUrl != null)
      {
        writer.WritePropertyName("_fixedUrl");
        _FixedUrl.SerializeJson(writer, options);
      }

      if (FixedUuid != null)
      {
        writer.WriteString("fixedUuid", (Guid)FixedUuid!);
      }

      if (FixedAddress != null)
      {
        writer.WritePropertyName("fixedAddress");
        FixedAddress.SerializeJson(writer, options);
      }

      if (FixedAge != null)
      {
        writer.WritePropertyName("fixedAge");
        FixedAge.SerializeJson(writer, options);
      }

      if (FixedAnnotation != null)
      {
        writer.WritePropertyName("fixedAnnotation");
        FixedAnnotation.SerializeJson(writer, options);
      }

      if (FixedAttachment != null)
      {
        writer.WritePropertyName("fixedAttachment");
        FixedAttachment.SerializeJson(writer, options);
      }

      if (FixedCodeableConcept != null)
      {
        writer.WritePropertyName("fixedCodeableConcept");
        FixedCodeableConcept.SerializeJson(writer, options);
      }

      if (FixedCoding != null)
      {
        writer.WritePropertyName("fixedCoding");
        FixedCoding.SerializeJson(writer, options);
      }

      if (FixedContactPoint != null)
      {
        writer.WritePropertyName("fixedContactPoint");
        FixedContactPoint.SerializeJson(writer, options);
      }

      if (FixedCount != null)
      {
        writer.WritePropertyName("fixedCount");
        FixedCount.SerializeJson(writer, options);
      }

      if (FixedDistance != null)
      {
        writer.WritePropertyName("fixedDistance");
        FixedDistance.SerializeJson(writer, options);
      }

      if (FixedDuration != null)
      {
        writer.WritePropertyName("fixedDuration");
        FixedDuration.SerializeJson(writer, options);
      }

      if (FixedHumanName != null)
      {
        writer.WritePropertyName("fixedHumanName");
        FixedHumanName.SerializeJson(writer, options);
      }

      if (FixedIdentifier != null)
      {
        writer.WritePropertyName("fixedIdentifier");
        FixedIdentifier.SerializeJson(writer, options);
      }

      if (FixedMoney != null)
      {
        writer.WritePropertyName("fixedMoney");
        FixedMoney.SerializeJson(writer, options);
      }

      if (FixedPeriod != null)
      {
        writer.WritePropertyName("fixedPeriod");
        FixedPeriod.SerializeJson(writer, options);
      }

      if (FixedQuantity != null)
      {
        writer.WritePropertyName("fixedQuantity");
        FixedQuantity.SerializeJson(writer, options);
      }

      if (FixedRange != null)
      {
        writer.WritePropertyName("fixedRange");
        FixedRange.SerializeJson(writer, options);
      }

      if (FixedRatio != null)
      {
        writer.WritePropertyName("fixedRatio");
        FixedRatio.SerializeJson(writer, options);
      }

      if (FixedReference != null)
      {
        writer.WritePropertyName("fixedReference");
        FixedReference.SerializeJson(writer, options);
      }

      if (FixedSampledData != null)
      {
        writer.WritePropertyName("fixedSampledData");
        FixedSampledData.SerializeJson(writer, options);
      }

      if (FixedSignature != null)
      {
        writer.WritePropertyName("fixedSignature");
        FixedSignature.SerializeJson(writer, options);
      }

      if (FixedTiming != null)
      {
        writer.WritePropertyName("fixedTiming");
        FixedTiming.SerializeJson(writer, options);
      }

      if (FixedContactDetail != null)
      {
        writer.WritePropertyName("fixedContactDetail");
        FixedContactDetail.SerializeJson(writer, options);
      }

      if (FixedContributor != null)
      {
        writer.WritePropertyName("fixedContributor");
        FixedContributor.SerializeJson(writer, options);
      }

      if (FixedDataRequirement != null)
      {
        writer.WritePropertyName("fixedDataRequirement");
        FixedDataRequirement.SerializeJson(writer, options);
      }

      if (FixedExpression != null)
      {
        writer.WritePropertyName("fixedExpression");
        FixedExpression.SerializeJson(writer, options);
      }

      if (FixedParameterDefinition != null)
      {
        writer.WritePropertyName("fixedParameterDefinition");
        FixedParameterDefinition.SerializeJson(writer, options);
      }

      if (FixedRelatedArtifact != null)
      {
        writer.WritePropertyName("fixedRelatedArtifact");
        FixedRelatedArtifact.SerializeJson(writer, options);
      }

      if (FixedTriggerDefinition != null)
      {
        writer.WritePropertyName("fixedTriggerDefinition");
        FixedTriggerDefinition.SerializeJson(writer, options);
      }

      if (FixedUsageContext != null)
      {
        writer.WritePropertyName("fixedUsageContext");
        FixedUsageContext.SerializeJson(writer, options);
      }

      if (FixedDosage != null)
      {
        writer.WritePropertyName("fixedDosage");
        FixedDosage.SerializeJson(writer, options);
      }

      if (FixedMeta != null)
      {
        writer.WritePropertyName("fixedMeta");
        FixedMeta.SerializeJson(writer, options);
      }

      if (PatternBase64Binary != null)
      {
        writer.WriteString("patternBase64Binary", System.Convert.ToBase64String(PatternBase64Binary));
      }

      if (PatternBoolean != null)
      {
        writer.WriteBoolean("patternBoolean", (bool)PatternBoolean!);
      }

      if (!string.IsNullOrEmpty(PatternCanonical))
      {
        writer.WriteString("patternCanonical", (string)PatternCanonical!);
      }

      if (_PatternCanonical != null)
      {
        writer.WritePropertyName("_patternCanonical");
        _PatternCanonical.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternCode))
      {
        writer.WriteString("patternCode", (string)PatternCode!);
      }

      if (_PatternCode != null)
      {
        writer.WritePropertyName("_patternCode");
        _PatternCode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternDate))
      {
        writer.WriteString("patternDate", (string)PatternDate!);
      }

      if (_PatternDate != null)
      {
        writer.WritePropertyName("_patternDate");
        _PatternDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternDateTime))
      {
        writer.WriteString("patternDateTime", (string)PatternDateTime!);
      }

      if (_PatternDateTime != null)
      {
        writer.WritePropertyName("_patternDateTime");
        _PatternDateTime.SerializeJson(writer, options);
      }

      if (PatternDecimal != null)
      {
        writer.WriteNumber("patternDecimal", (decimal)PatternDecimal!);
      }

      if (_PatternDecimal != null)
      {
        writer.WritePropertyName("_patternDecimal");
        _PatternDecimal.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternId))
      {
        writer.WriteString("patternId", (string)PatternId!);
      }

      if (_PatternId != null)
      {
        writer.WritePropertyName("_patternId");
        _PatternId.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternInstant))
      {
        writer.WriteString("patternInstant", (string)PatternInstant!);
      }

      if (_PatternInstant != null)
      {
        writer.WritePropertyName("_patternInstant");
        _PatternInstant.SerializeJson(writer, options);
      }

      if (PatternInteger != null)
      {
        writer.WriteNumber("patternInteger", (int)PatternInteger!);
      }

      if (!string.IsNullOrEmpty(PatternMarkdown))
      {
        writer.WriteString("patternMarkdown", (string)PatternMarkdown!);
      }

      if (_PatternMarkdown != null)
      {
        writer.WritePropertyName("_patternMarkdown");
        _PatternMarkdown.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternOid))
      {
        writer.WriteString("patternOid", (string)PatternOid!);
      }

      if (_PatternOid != null)
      {
        writer.WritePropertyName("_patternOid");
        _PatternOid.SerializeJson(writer, options);
      }

      if (PatternPositiveInt != null)
      {
        writer.WriteNumber("patternPositiveInt", (uint)PatternPositiveInt!);
      }

      if (!string.IsNullOrEmpty(PatternString))
      {
        writer.WriteString("patternString", (string)PatternString!);
      }

      if (_PatternString != null)
      {
        writer.WritePropertyName("_patternString");
        _PatternString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternTime))
      {
        writer.WriteString("patternTime", (string)PatternTime!);
      }

      if (_PatternTime != null)
      {
        writer.WritePropertyName("_patternTime");
        _PatternTime.SerializeJson(writer, options);
      }

      if (PatternUnsignedInt != null)
      {
        writer.WriteNumber("patternUnsignedInt", (uint)PatternUnsignedInt!);
      }

      if (!string.IsNullOrEmpty(PatternUri))
      {
        writer.WriteString("patternUri", (string)PatternUri!);
      }

      if (_PatternUri != null)
      {
        writer.WritePropertyName("_patternUri");
        _PatternUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PatternUrl))
      {
        writer.WriteString("patternUrl", (string)PatternUrl!);
      }

      if (_PatternUrl != null)
      {
        writer.WritePropertyName("_patternUrl");
        _PatternUrl.SerializeJson(writer, options);
      }

      if (PatternUuid != null)
      {
        writer.WriteString("patternUuid", (Guid)PatternUuid!);
      }

      if (PatternAddress != null)
      {
        writer.WritePropertyName("patternAddress");
        PatternAddress.SerializeJson(writer, options);
      }

      if (PatternAge != null)
      {
        writer.WritePropertyName("patternAge");
        PatternAge.SerializeJson(writer, options);
      }

      if (PatternAnnotation != null)
      {
        writer.WritePropertyName("patternAnnotation");
        PatternAnnotation.SerializeJson(writer, options);
      }

      if (PatternAttachment != null)
      {
        writer.WritePropertyName("patternAttachment");
        PatternAttachment.SerializeJson(writer, options);
      }

      if (PatternCodeableConcept != null)
      {
        writer.WritePropertyName("patternCodeableConcept");
        PatternCodeableConcept.SerializeJson(writer, options);
      }

      if (PatternCoding != null)
      {
        writer.WritePropertyName("patternCoding");
        PatternCoding.SerializeJson(writer, options);
      }

      if (PatternContactPoint != null)
      {
        writer.WritePropertyName("patternContactPoint");
        PatternContactPoint.SerializeJson(writer, options);
      }

      if (PatternCount != null)
      {
        writer.WritePropertyName("patternCount");
        PatternCount.SerializeJson(writer, options);
      }

      if (PatternDistance != null)
      {
        writer.WritePropertyName("patternDistance");
        PatternDistance.SerializeJson(writer, options);
      }

      if (PatternDuration != null)
      {
        writer.WritePropertyName("patternDuration");
        PatternDuration.SerializeJson(writer, options);
      }

      if (PatternHumanName != null)
      {
        writer.WritePropertyName("patternHumanName");
        PatternHumanName.SerializeJson(writer, options);
      }

      if (PatternIdentifier != null)
      {
        writer.WritePropertyName("patternIdentifier");
        PatternIdentifier.SerializeJson(writer, options);
      }

      if (PatternMoney != null)
      {
        writer.WritePropertyName("patternMoney");
        PatternMoney.SerializeJson(writer, options);
      }

      if (PatternPeriod != null)
      {
        writer.WritePropertyName("patternPeriod");
        PatternPeriod.SerializeJson(writer, options);
      }

      if (PatternQuantity != null)
      {
        writer.WritePropertyName("patternQuantity");
        PatternQuantity.SerializeJson(writer, options);
      }

      if (PatternRange != null)
      {
        writer.WritePropertyName("patternRange");
        PatternRange.SerializeJson(writer, options);
      }

      if (PatternRatio != null)
      {
        writer.WritePropertyName("patternRatio");
        PatternRatio.SerializeJson(writer, options);
      }

      if (PatternReference != null)
      {
        writer.WritePropertyName("patternReference");
        PatternReference.SerializeJson(writer, options);
      }

      if (PatternSampledData != null)
      {
        writer.WritePropertyName("patternSampledData");
        PatternSampledData.SerializeJson(writer, options);
      }

      if (PatternSignature != null)
      {
        writer.WritePropertyName("patternSignature");
        PatternSignature.SerializeJson(writer, options);
      }

      if (PatternTiming != null)
      {
        writer.WritePropertyName("patternTiming");
        PatternTiming.SerializeJson(writer, options);
      }

      if (PatternContactDetail != null)
      {
        writer.WritePropertyName("patternContactDetail");
        PatternContactDetail.SerializeJson(writer, options);
      }

      if (PatternContributor != null)
      {
        writer.WritePropertyName("patternContributor");
        PatternContributor.SerializeJson(writer, options);
      }

      if (PatternDataRequirement != null)
      {
        writer.WritePropertyName("patternDataRequirement");
        PatternDataRequirement.SerializeJson(writer, options);
      }

      if (PatternExpression != null)
      {
        writer.WritePropertyName("patternExpression");
        PatternExpression.SerializeJson(writer, options);
      }

      if (PatternParameterDefinition != null)
      {
        writer.WritePropertyName("patternParameterDefinition");
        PatternParameterDefinition.SerializeJson(writer, options);
      }

      if (PatternRelatedArtifact != null)
      {
        writer.WritePropertyName("patternRelatedArtifact");
        PatternRelatedArtifact.SerializeJson(writer, options);
      }

      if (PatternTriggerDefinition != null)
      {
        writer.WritePropertyName("patternTriggerDefinition");
        PatternTriggerDefinition.SerializeJson(writer, options);
      }

      if (PatternUsageContext != null)
      {
        writer.WritePropertyName("patternUsageContext");
        PatternUsageContext.SerializeJson(writer, options);
      }

      if (PatternDosage != null)
      {
        writer.WritePropertyName("patternDosage");
        PatternDosage.SerializeJson(writer, options);
      }

      if (PatternMeta != null)
      {
        writer.WritePropertyName("patternMeta");
        PatternMeta.SerializeJson(writer, options);
      }

      if ((Example != null) && (Example.Count != 0))
      {
        writer.WritePropertyName("example");
        writer.WriteStartArray();

        foreach (ElementDefinitionExample valExample in Example)
        {
          valExample.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(MinValueDate))
      {
        writer.WriteString("minValueDate", (string)MinValueDate!);
      }

      if (_MinValueDate != null)
      {
        writer.WritePropertyName("_minValueDate");
        _MinValueDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueDateTime))
      {
        writer.WriteString("minValueDateTime", (string)MinValueDateTime!);
      }

      if (_MinValueDateTime != null)
      {
        writer.WritePropertyName("_minValueDateTime");
        _MinValueDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueInstant))
      {
        writer.WriteString("minValueInstant", (string)MinValueInstant!);
      }

      if (_MinValueInstant != null)
      {
        writer.WritePropertyName("_minValueInstant");
        _MinValueInstant.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MinValueTime))
      {
        writer.WriteString("minValueTime", (string)MinValueTime!);
      }

      if (_MinValueTime != null)
      {
        writer.WritePropertyName("_minValueTime");
        _MinValueTime.SerializeJson(writer, options);
      }

      if (MinValueDecimal != null)
      {
        writer.WriteNumber("minValueDecimal", (decimal)MinValueDecimal!);
      }

      if (_MinValueDecimal != null)
      {
        writer.WritePropertyName("_minValueDecimal");
        _MinValueDecimal.SerializeJson(writer, options);
      }

      if (MinValueInteger != null)
      {
        writer.WriteNumber("minValueInteger", (int)MinValueInteger!);
      }

      if (MinValuePositiveInt != null)
      {
        writer.WriteNumber("minValuePositiveInt", (uint)MinValuePositiveInt!);
      }

      if (MinValueUnsignedInt != null)
      {
        writer.WriteNumber("minValueUnsignedInt", (uint)MinValueUnsignedInt!);
      }

      if (MinValueQuantity != null)
      {
        writer.WritePropertyName("minValueQuantity");
        MinValueQuantity.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueDate))
      {
        writer.WriteString("maxValueDate", (string)MaxValueDate!);
      }

      if (_MaxValueDate != null)
      {
        writer.WritePropertyName("_maxValueDate");
        _MaxValueDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueDateTime))
      {
        writer.WriteString("maxValueDateTime", (string)MaxValueDateTime!);
      }

      if (_MaxValueDateTime != null)
      {
        writer.WritePropertyName("_maxValueDateTime");
        _MaxValueDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueInstant))
      {
        writer.WriteString("maxValueInstant", (string)MaxValueInstant!);
      }

      if (_MaxValueInstant != null)
      {
        writer.WritePropertyName("_maxValueInstant");
        _MaxValueInstant.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(MaxValueTime))
      {
        writer.WriteString("maxValueTime", (string)MaxValueTime!);
      }

      if (_MaxValueTime != null)
      {
        writer.WritePropertyName("_maxValueTime");
        _MaxValueTime.SerializeJson(writer, options);
      }

      if (MaxValueDecimal != null)
      {
        writer.WriteNumber("maxValueDecimal", (decimal)MaxValueDecimal!);
      }

      if (_MaxValueDecimal != null)
      {
        writer.WritePropertyName("_maxValueDecimal");
        _MaxValueDecimal.SerializeJson(writer, options);
      }

      if (MaxValueInteger != null)
      {
        writer.WriteNumber("maxValueInteger", (int)MaxValueInteger!);
      }

      if (MaxValuePositiveInt != null)
      {
        writer.WriteNumber("maxValuePositiveInt", (uint)MaxValuePositiveInt!);
      }

      if (MaxValueUnsignedInt != null)
      {
        writer.WriteNumber("maxValueUnsignedInt", (uint)MaxValueUnsignedInt!);
      }

      if (MaxValueQuantity != null)
      {
        writer.WritePropertyName("maxValueQuantity");
        MaxValueQuantity.SerializeJson(writer, options);
      }

      if (MaxLength != null)
      {
        writer.WriteNumber("maxLength", (int)MaxLength!);
      }

      if ((Condition != null) && (Condition.Count != 0))
      {
        writer.WritePropertyName("condition");
        writer.WriteStartArray();

        foreach (string valCondition in Condition)
        {
          writer.WriteStringValue(valCondition);
        }

        writer.WriteEndArray();
      }

      if ((_Condition != null) && (_Condition.Count != 0))
      {
        writer.WritePropertyName("_condition");
        writer.WriteStartArray();

        foreach (Element val_Condition in _Condition)
        {
          val_Condition.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Constraint != null) && (Constraint.Count != 0))
      {
        writer.WritePropertyName("constraint");
        writer.WriteStartArray();

        foreach (ElementDefinitionConstraint valConstraint in Constraint)
        {
          valConstraint.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (MustSupport != null)
      {
        writer.WriteBoolean("mustSupport", (bool)MustSupport!);
      }

      if (IsModifier != null)
      {
        writer.WriteBoolean("isModifier", (bool)IsModifier!);
      }

      if (!string.IsNullOrEmpty(IsModifierReason))
      {
        writer.WriteString("isModifierReason", (string)IsModifierReason!);
      }

      if (_IsModifierReason != null)
      {
        writer.WritePropertyName("_isModifierReason");
        _IsModifierReason.SerializeJson(writer, options);
      }

      if (IsSummary != null)
      {
        writer.WriteBoolean("isSummary", (bool)IsSummary!);
      }

      if (Binding != null)
      {
        writer.WritePropertyName("binding");
        Binding.SerializeJson(writer, options);
      }

      if ((Mapping != null) && (Mapping.Count != 0))
      {
        writer.WritePropertyName("mapping");
        writer.WriteStartArray();

        foreach (ElementDefinitionMapping valMapping in Mapping)
        {
          valMapping.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "alias":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Alias = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Alias.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Alias.Count == 0)
          {
            Alias = null;
          }

          break;

        case "_alias":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Alias = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Element obj_Alias = new fhirCsR4.Models.Element();
            obj_Alias.DeserializeJson(ref reader, options);
            _Alias.Add(obj_Alias);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Alias.Count == 0)
          {
            _Alias = null;
          }

          break;

        case "base":
          Base = new fhirCsR4.Models.ElementDefinitionBase();
          Base.DeserializeJson(ref reader, options);
          break;

        case "binding":
          Binding = new fhirCsR4.Models.ElementDefinitionBinding();
          Binding.DeserializeJson(ref reader, options);
          break;

        case "code":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Code = new List<Coding>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Coding objCode = new fhirCsR4.Models.Coding();
            objCode.DeserializeJson(ref reader, options);
            Code.Add(objCode);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Code.Count == 0)
          {
            Code = null;
          }

          break;

        case "comment":
          Comment = reader.GetString();
          break;

        case "_comment":
          _Comment = new fhirCsR4.Models.Element();
          _Comment.DeserializeJson(ref reader, options);
          break;

        case "condition":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Condition = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Condition.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Condition.Count == 0)
          {
            Condition = null;
          }

          break;

        case "_condition":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Condition = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Element obj_Condition = new fhirCsR4.Models.Element();
            obj_Condition.DeserializeJson(ref reader, options);
            _Condition.Add(obj_Condition);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Condition.Count == 0)
          {
            _Condition = null;
          }

          break;

        case "constraint":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Constraint = new List<ElementDefinitionConstraint>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ElementDefinitionConstraint objConstraint = new fhirCsR4.Models.ElementDefinitionConstraint();
            objConstraint.DeserializeJson(ref reader, options);
            Constraint.Add(objConstraint);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Constraint.Count == 0)
          {
            Constraint = null;
          }

          break;

        case "contentReference":
          ContentReference = reader.GetString();
          break;

        case "_contentReference":
          _ContentReference = new fhirCsR4.Models.Element();
          _ContentReference.DeserializeJson(ref reader, options);
          break;

        case "defaultValueBase64Binary":
          DefaultValueBase64Binary = System.Convert.FromBase64String(reader.GetString());
          break;

        case "defaultValueBoolean":
          DefaultValueBoolean = reader.GetBoolean();
          break;

        case "defaultValueCanonical":
          DefaultValueCanonical = reader.GetString();
          break;

        case "_defaultValueCanonical":
          _DefaultValueCanonical = new fhirCsR4.Models.Element();
          _DefaultValueCanonical.DeserializeJson(ref reader, options);
          break;

        case "defaultValueCode":
          DefaultValueCode = reader.GetString();
          break;

        case "_defaultValueCode":
          _DefaultValueCode = new fhirCsR4.Models.Element();
          _DefaultValueCode.DeserializeJson(ref reader, options);
          break;

        case "defaultValueDate":
          DefaultValueDate = reader.GetString();
          break;

        case "_defaultValueDate":
          _DefaultValueDate = new fhirCsR4.Models.Element();
          _DefaultValueDate.DeserializeJson(ref reader, options);
          break;

        case "defaultValueDateTime":
          DefaultValueDateTime = reader.GetString();
          break;

        case "_defaultValueDateTime":
          _DefaultValueDateTime = new fhirCsR4.Models.Element();
          _DefaultValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "defaultValueDecimal":
          DefaultValueDecimal = reader.GetDecimal();
          break;

        case "_defaultValueDecimal":
          _DefaultValueDecimal = new fhirCsR4.Models.Element();
          _DefaultValueDecimal.DeserializeJson(ref reader, options);
          break;

        case "defaultValueId":
          DefaultValueId = reader.GetString();
          break;

        case "_defaultValueId":
          _DefaultValueId = new fhirCsR4.Models.Element();
          _DefaultValueId.DeserializeJson(ref reader, options);
          break;

        case "defaultValueInstant":
          DefaultValueInstant = reader.GetString();
          break;

        case "_defaultValueInstant":
          _DefaultValueInstant = new fhirCsR4.Models.Element();
          _DefaultValueInstant.DeserializeJson(ref reader, options);
          break;

        case "defaultValueInteger":
          DefaultValueInteger = reader.GetInt32();
          break;

        case "defaultValueMarkdown":
          DefaultValueMarkdown = reader.GetString();
          break;

        case "_defaultValueMarkdown":
          _DefaultValueMarkdown = new fhirCsR4.Models.Element();
          _DefaultValueMarkdown.DeserializeJson(ref reader, options);
          break;

        case "defaultValueOid":
          DefaultValueOid = reader.GetString();
          break;

        case "_defaultValueOid":
          _DefaultValueOid = new fhirCsR4.Models.Element();
          _DefaultValueOid.DeserializeJson(ref reader, options);
          break;

        case "defaultValuePositiveInt":
          DefaultValuePositiveInt = reader.GetUInt32();
          break;

        case "defaultValueString":
          DefaultValueString = reader.GetString();
          break;

        case "_defaultValueString":
          _DefaultValueString = new fhirCsR4.Models.Element();
          _DefaultValueString.DeserializeJson(ref reader, options);
          break;

        case "defaultValueTime":
          DefaultValueTime = reader.GetString();
          break;

        case "_defaultValueTime":
          _DefaultValueTime = new fhirCsR4.Models.Element();
          _DefaultValueTime.DeserializeJson(ref reader, options);
          break;

        case "defaultValueUnsignedInt":
          DefaultValueUnsignedInt = reader.GetUInt32();
          break;

        case "defaultValueUri":
          DefaultValueUri = reader.GetString();
          break;

        case "_defaultValueUri":
          _DefaultValueUri = new fhirCsR4.Models.Element();
          _DefaultValueUri.DeserializeJson(ref reader, options);
          break;

        case "defaultValueUrl":
          DefaultValueUrl = reader.GetString();
          break;

        case "_defaultValueUrl":
          _DefaultValueUrl = new fhirCsR4.Models.Element();
          _DefaultValueUrl.DeserializeJson(ref reader, options);
          break;

        case "defaultValueUuid":
          DefaultValueUuid = reader.GetGuid();
          break;

        case "defaultValueAddress":
          DefaultValueAddress = new fhirCsR4.Models.Address();
          DefaultValueAddress.DeserializeJson(ref reader, options);
          break;

        case "defaultValueAge":
          DefaultValueAge = new fhirCsR4.Models.Age();
          DefaultValueAge.DeserializeJson(ref reader, options);
          break;

        case "defaultValueAnnotation":
          DefaultValueAnnotation = new fhirCsR4.Models.Annotation();
          DefaultValueAnnotation.DeserializeJson(ref reader, options);
          break;

        case "defaultValueAttachment":
          DefaultValueAttachment = new fhirCsR4.Models.Attachment();
          DefaultValueAttachment.DeserializeJson(ref reader, options);
          break;

        case "defaultValueCodeableConcept":
          DefaultValueCodeableConcept = new fhirCsR4.Models.CodeableConcept();
          DefaultValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "defaultValueCoding":
          DefaultValueCoding = new fhirCsR4.Models.Coding();
          DefaultValueCoding.DeserializeJson(ref reader, options);
          break;

        case "defaultValueContactPoint":
          DefaultValueContactPoint = new fhirCsR4.Models.ContactPoint();
          DefaultValueContactPoint.DeserializeJson(ref reader, options);
          break;

        case "defaultValueCount":
          DefaultValueCount = new fhirCsR4.Models.Count();
          DefaultValueCount.DeserializeJson(ref reader, options);
          break;

        case "defaultValueDistance":
          DefaultValueDistance = new fhirCsR4.Models.Distance();
          DefaultValueDistance.DeserializeJson(ref reader, options);
          break;

        case "defaultValueDuration":
          DefaultValueDuration = new fhirCsR4.Models.Duration();
          DefaultValueDuration.DeserializeJson(ref reader, options);
          break;

        case "defaultValueHumanName":
          DefaultValueHumanName = new fhirCsR4.Models.HumanName();
          DefaultValueHumanName.DeserializeJson(ref reader, options);
          break;

        case "defaultValueIdentifier":
          DefaultValueIdentifier = new fhirCsR4.Models.Identifier();
          DefaultValueIdentifier.DeserializeJson(ref reader, options);
          break;

        case "defaultValueMoney":
          DefaultValueMoney = new fhirCsR4.Models.Money();
          DefaultValueMoney.DeserializeJson(ref reader, options);
          break;

        case "defaultValuePeriod":
          DefaultValuePeriod = new fhirCsR4.Models.Period();
          DefaultValuePeriod.DeserializeJson(ref reader, options);
          break;

        case "defaultValueQuantity":
          DefaultValueQuantity = new fhirCsR4.Models.Quantity();
          DefaultValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "defaultValueRange":
          DefaultValueRange = new fhirCsR4.Models.Range();
          DefaultValueRange.DeserializeJson(ref reader, options);
          break;

        case "defaultValueRatio":
          DefaultValueRatio = new fhirCsR4.Models.Ratio();
          DefaultValueRatio.DeserializeJson(ref reader, options);
          break;

        case "defaultValueReference":
          DefaultValueReference = new fhirCsR4.Models.Reference();
          DefaultValueReference.DeserializeJson(ref reader, options);
          break;

        case "defaultValueSampledData":
          DefaultValueSampledData = new fhirCsR4.Models.SampledData();
          DefaultValueSampledData.DeserializeJson(ref reader, options);
          break;

        case "defaultValueSignature":
          DefaultValueSignature = new fhirCsR4.Models.Signature();
          DefaultValueSignature.DeserializeJson(ref reader, options);
          break;

        case "defaultValueTiming":
          DefaultValueTiming = new fhirCsR4.Models.Timing();
          DefaultValueTiming.DeserializeJson(ref reader, options);
          break;

        case "defaultValueContactDetail":
          DefaultValueContactDetail = new fhirCsR4.Models.ContactDetail();
          DefaultValueContactDetail.DeserializeJson(ref reader, options);
          break;

        case "defaultValueContributor":
          DefaultValueContributor = new fhirCsR4.Models.Contributor();
          DefaultValueContributor.DeserializeJson(ref reader, options);
          break;

        case "defaultValueDataRequirement":
          DefaultValueDataRequirement = new fhirCsR4.Models.DataRequirement();
          DefaultValueDataRequirement.DeserializeJson(ref reader, options);
          break;

        case "defaultValueExpression":
          DefaultValueExpression = new fhirCsR4.Models.Expression();
          DefaultValueExpression.DeserializeJson(ref reader, options);
          break;

        case "defaultValueParameterDefinition":
          DefaultValueParameterDefinition = new fhirCsR4.Models.ParameterDefinition();
          DefaultValueParameterDefinition.DeserializeJson(ref reader, options);
          break;

        case "defaultValueRelatedArtifact":
          DefaultValueRelatedArtifact = new fhirCsR4.Models.RelatedArtifact();
          DefaultValueRelatedArtifact.DeserializeJson(ref reader, options);
          break;

        case "defaultValueTriggerDefinition":
          DefaultValueTriggerDefinition = new fhirCsR4.Models.TriggerDefinition();
          DefaultValueTriggerDefinition.DeserializeJson(ref reader, options);
          break;

        case "defaultValueUsageContext":
          DefaultValueUsageContext = new fhirCsR4.Models.UsageContext();
          DefaultValueUsageContext.DeserializeJson(ref reader, options);
          break;

        case "defaultValueDosage":
          DefaultValueDosage = new fhirCsR4.Models.Dosage();
          DefaultValueDosage.DeserializeJson(ref reader, options);
          break;

        case "defaultValueMeta":
          DefaultValueMeta = new fhirCsR4.Models.Meta();
          DefaultValueMeta.DeserializeJson(ref reader, options);
          break;

        case "definition":
          Definition = reader.GetString();
          break;

        case "_definition":
          _Definition = new fhirCsR4.Models.Element();
          _Definition.DeserializeJson(ref reader, options);
          break;

        case "example":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Example = new List<ElementDefinitionExample>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ElementDefinitionExample objExample = new fhirCsR4.Models.ElementDefinitionExample();
            objExample.DeserializeJson(ref reader, options);
            Example.Add(objExample);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Example.Count == 0)
          {
            Example = null;
          }

          break;

        case "fixedBase64Binary":
          FixedBase64Binary = System.Convert.FromBase64String(reader.GetString());
          break;

        case "fixedBoolean":
          FixedBoolean = reader.GetBoolean();
          break;

        case "fixedCanonical":
          FixedCanonical = reader.GetString();
          break;

        case "_fixedCanonical":
          _FixedCanonical = new fhirCsR4.Models.Element();
          _FixedCanonical.DeserializeJson(ref reader, options);
          break;

        case "fixedCode":
          FixedCode = reader.GetString();
          break;

        case "_fixedCode":
          _FixedCode = new fhirCsR4.Models.Element();
          _FixedCode.DeserializeJson(ref reader, options);
          break;

        case "fixedDate":
          FixedDate = reader.GetString();
          break;

        case "_fixedDate":
          _FixedDate = new fhirCsR4.Models.Element();
          _FixedDate.DeserializeJson(ref reader, options);
          break;

        case "fixedDateTime":
          FixedDateTime = reader.GetString();
          break;

        case "_fixedDateTime":
          _FixedDateTime = new fhirCsR4.Models.Element();
          _FixedDateTime.DeserializeJson(ref reader, options);
          break;

        case "fixedDecimal":
          FixedDecimal = reader.GetDecimal();
          break;

        case "_fixedDecimal":
          _FixedDecimal = new fhirCsR4.Models.Element();
          _FixedDecimal.DeserializeJson(ref reader, options);
          break;

        case "fixedId":
          FixedId = reader.GetString();
          break;

        case "_fixedId":
          _FixedId = new fhirCsR4.Models.Element();
          _FixedId.DeserializeJson(ref reader, options);
          break;

        case "fixedInstant":
          FixedInstant = reader.GetString();
          break;

        case "_fixedInstant":
          _FixedInstant = new fhirCsR4.Models.Element();
          _FixedInstant.DeserializeJson(ref reader, options);
          break;

        case "fixedInteger":
          FixedInteger = reader.GetInt32();
          break;

        case "fixedMarkdown":
          FixedMarkdown = reader.GetString();
          break;

        case "_fixedMarkdown":
          _FixedMarkdown = new fhirCsR4.Models.Element();
          _FixedMarkdown.DeserializeJson(ref reader, options);
          break;

        case "fixedOid":
          FixedOid = reader.GetString();
          break;

        case "_fixedOid":
          _FixedOid = new fhirCsR4.Models.Element();
          _FixedOid.DeserializeJson(ref reader, options);
          break;

        case "fixedPositiveInt":
          FixedPositiveInt = reader.GetUInt32();
          break;

        case "fixedString":
          FixedString = reader.GetString();
          break;

        case "_fixedString":
          _FixedString = new fhirCsR4.Models.Element();
          _FixedString.DeserializeJson(ref reader, options);
          break;

        case "fixedTime":
          FixedTime = reader.GetString();
          break;

        case "_fixedTime":
          _FixedTime = new fhirCsR4.Models.Element();
          _FixedTime.DeserializeJson(ref reader, options);
          break;

        case "fixedUnsignedInt":
          FixedUnsignedInt = reader.GetUInt32();
          break;

        case "fixedUri":
          FixedUri = reader.GetString();
          break;

        case "_fixedUri":
          _FixedUri = new fhirCsR4.Models.Element();
          _FixedUri.DeserializeJson(ref reader, options);
          break;

        case "fixedUrl":
          FixedUrl = reader.GetString();
          break;

        case "_fixedUrl":
          _FixedUrl = new fhirCsR4.Models.Element();
          _FixedUrl.DeserializeJson(ref reader, options);
          break;

        case "fixedUuid":
          FixedUuid = reader.GetGuid();
          break;

        case "fixedAddress":
          FixedAddress = new fhirCsR4.Models.Address();
          FixedAddress.DeserializeJson(ref reader, options);
          break;

        case "fixedAge":
          FixedAge = new fhirCsR4.Models.Age();
          FixedAge.DeserializeJson(ref reader, options);
          break;

        case "fixedAnnotation":
          FixedAnnotation = new fhirCsR4.Models.Annotation();
          FixedAnnotation.DeserializeJson(ref reader, options);
          break;

        case "fixedAttachment":
          FixedAttachment = new fhirCsR4.Models.Attachment();
          FixedAttachment.DeserializeJson(ref reader, options);
          break;

        case "fixedCodeableConcept":
          FixedCodeableConcept = new fhirCsR4.Models.CodeableConcept();
          FixedCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "fixedCoding":
          FixedCoding = new fhirCsR4.Models.Coding();
          FixedCoding.DeserializeJson(ref reader, options);
          break;

        case "fixedContactPoint":
          FixedContactPoint = new fhirCsR4.Models.ContactPoint();
          FixedContactPoint.DeserializeJson(ref reader, options);
          break;

        case "fixedCount":
          FixedCount = new fhirCsR4.Models.Count();
          FixedCount.DeserializeJson(ref reader, options);
          break;

        case "fixedDistance":
          FixedDistance = new fhirCsR4.Models.Distance();
          FixedDistance.DeserializeJson(ref reader, options);
          break;

        case "fixedDuration":
          FixedDuration = new fhirCsR4.Models.Duration();
          FixedDuration.DeserializeJson(ref reader, options);
          break;

        case "fixedHumanName":
          FixedHumanName = new fhirCsR4.Models.HumanName();
          FixedHumanName.DeserializeJson(ref reader, options);
          break;

        case "fixedIdentifier":
          FixedIdentifier = new fhirCsR4.Models.Identifier();
          FixedIdentifier.DeserializeJson(ref reader, options);
          break;

        case "fixedMoney":
          FixedMoney = new fhirCsR4.Models.Money();
          FixedMoney.DeserializeJson(ref reader, options);
          break;

        case "fixedPeriod":
          FixedPeriod = new fhirCsR4.Models.Period();
          FixedPeriod.DeserializeJson(ref reader, options);
          break;

        case "fixedQuantity":
          FixedQuantity = new fhirCsR4.Models.Quantity();
          FixedQuantity.DeserializeJson(ref reader, options);
          break;

        case "fixedRange":
          FixedRange = new fhirCsR4.Models.Range();
          FixedRange.DeserializeJson(ref reader, options);
          break;

        case "fixedRatio":
          FixedRatio = new fhirCsR4.Models.Ratio();
          FixedRatio.DeserializeJson(ref reader, options);
          break;

        case "fixedReference":
          FixedReference = new fhirCsR4.Models.Reference();
          FixedReference.DeserializeJson(ref reader, options);
          break;

        case "fixedSampledData":
          FixedSampledData = new fhirCsR4.Models.SampledData();
          FixedSampledData.DeserializeJson(ref reader, options);
          break;

        case "fixedSignature":
          FixedSignature = new fhirCsR4.Models.Signature();
          FixedSignature.DeserializeJson(ref reader, options);
          break;

        case "fixedTiming":
          FixedTiming = new fhirCsR4.Models.Timing();
          FixedTiming.DeserializeJson(ref reader, options);
          break;

        case "fixedContactDetail":
          FixedContactDetail = new fhirCsR4.Models.ContactDetail();
          FixedContactDetail.DeserializeJson(ref reader, options);
          break;

        case "fixedContributor":
          FixedContributor = new fhirCsR4.Models.Contributor();
          FixedContributor.DeserializeJson(ref reader, options);
          break;

        case "fixedDataRequirement":
          FixedDataRequirement = new fhirCsR4.Models.DataRequirement();
          FixedDataRequirement.DeserializeJson(ref reader, options);
          break;

        case "fixedExpression":
          FixedExpression = new fhirCsR4.Models.Expression();
          FixedExpression.DeserializeJson(ref reader, options);
          break;

        case "fixedParameterDefinition":
          FixedParameterDefinition = new fhirCsR4.Models.ParameterDefinition();
          FixedParameterDefinition.DeserializeJson(ref reader, options);
          break;

        case "fixedRelatedArtifact":
          FixedRelatedArtifact = new fhirCsR4.Models.RelatedArtifact();
          FixedRelatedArtifact.DeserializeJson(ref reader, options);
          break;

        case "fixedTriggerDefinition":
          FixedTriggerDefinition = new fhirCsR4.Models.TriggerDefinition();
          FixedTriggerDefinition.DeserializeJson(ref reader, options);
          break;

        case "fixedUsageContext":
          FixedUsageContext = new fhirCsR4.Models.UsageContext();
          FixedUsageContext.DeserializeJson(ref reader, options);
          break;

        case "fixedDosage":
          FixedDosage = new fhirCsR4.Models.Dosage();
          FixedDosage.DeserializeJson(ref reader, options);
          break;

        case "fixedMeta":
          FixedMeta = new fhirCsR4.Models.Meta();
          FixedMeta.DeserializeJson(ref reader, options);
          break;

        case "isModifier":
          IsModifier = reader.GetBoolean();
          break;

        case "isModifierReason":
          IsModifierReason = reader.GetString();
          break;

        case "_isModifierReason":
          _IsModifierReason = new fhirCsR4.Models.Element();
          _IsModifierReason.DeserializeJson(ref reader, options);
          break;

        case "isSummary":
          IsSummary = reader.GetBoolean();
          break;

        case "label":
          Label = reader.GetString();
          break;

        case "_label":
          _Label = new fhirCsR4.Models.Element();
          _Label.DeserializeJson(ref reader, options);
          break;

        case "mapping":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Mapping = new List<ElementDefinitionMapping>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ElementDefinitionMapping objMapping = new fhirCsR4.Models.ElementDefinitionMapping();
            objMapping.DeserializeJson(ref reader, options);
            Mapping.Add(objMapping);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Mapping.Count == 0)
          {
            Mapping = null;
          }

          break;

        case "max":
          Max = reader.GetString();
          break;

        case "_max":
          _Max = new fhirCsR4.Models.Element();
          _Max.DeserializeJson(ref reader, options);
          break;

        case "maxLength":
          MaxLength = reader.GetInt32();
          break;

        case "maxValueDate":
          MaxValueDate = reader.GetString();
          break;

        case "_maxValueDate":
          _MaxValueDate = new fhirCsR4.Models.Element();
          _MaxValueDate.DeserializeJson(ref reader, options);
          break;

        case "maxValueDateTime":
          MaxValueDateTime = reader.GetString();
          break;

        case "_maxValueDateTime":
          _MaxValueDateTime = new fhirCsR4.Models.Element();
          _MaxValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "maxValueInstant":
          MaxValueInstant = reader.GetString();
          break;

        case "_maxValueInstant":
          _MaxValueInstant = new fhirCsR4.Models.Element();
          _MaxValueInstant.DeserializeJson(ref reader, options);
          break;

        case "maxValueTime":
          MaxValueTime = reader.GetString();
          break;

        case "_maxValueTime":
          _MaxValueTime = new fhirCsR4.Models.Element();
          _MaxValueTime.DeserializeJson(ref reader, options);
          break;

        case "maxValueDecimal":
          MaxValueDecimal = reader.GetDecimal();
          break;

        case "_maxValueDecimal":
          _MaxValueDecimal = new fhirCsR4.Models.Element();
          _MaxValueDecimal.DeserializeJson(ref reader, options);
          break;

        case "maxValueInteger":
          MaxValueInteger = reader.GetInt32();
          break;

        case "maxValuePositiveInt":
          MaxValuePositiveInt = reader.GetUInt32();
          break;

        case "maxValueUnsignedInt":
          MaxValueUnsignedInt = reader.GetUInt32();
          break;

        case "maxValueQuantity":
          MaxValueQuantity = new fhirCsR4.Models.Quantity();
          MaxValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "meaningWhenMissing":
          MeaningWhenMissing = reader.GetString();
          break;

        case "_meaningWhenMissing":
          _MeaningWhenMissing = new fhirCsR4.Models.Element();
          _MeaningWhenMissing.DeserializeJson(ref reader, options);
          break;

        case "min":
          Min = reader.GetUInt32();
          break;

        case "minValueDate":
          MinValueDate = reader.GetString();
          break;

        case "_minValueDate":
          _MinValueDate = new fhirCsR4.Models.Element();
          _MinValueDate.DeserializeJson(ref reader, options);
          break;

        case "minValueDateTime":
          MinValueDateTime = reader.GetString();
          break;

        case "_minValueDateTime":
          _MinValueDateTime = new fhirCsR4.Models.Element();
          _MinValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "minValueInstant":
          MinValueInstant = reader.GetString();
          break;

        case "_minValueInstant":
          _MinValueInstant = new fhirCsR4.Models.Element();
          _MinValueInstant.DeserializeJson(ref reader, options);
          break;

        case "minValueTime":
          MinValueTime = reader.GetString();
          break;

        case "_minValueTime":
          _MinValueTime = new fhirCsR4.Models.Element();
          _MinValueTime.DeserializeJson(ref reader, options);
          break;

        case "minValueDecimal":
          MinValueDecimal = reader.GetDecimal();
          break;

        case "_minValueDecimal":
          _MinValueDecimal = new fhirCsR4.Models.Element();
          _MinValueDecimal.DeserializeJson(ref reader, options);
          break;

        case "minValueInteger":
          MinValueInteger = reader.GetInt32();
          break;

        case "minValuePositiveInt":
          MinValuePositiveInt = reader.GetUInt32();
          break;

        case "minValueUnsignedInt":
          MinValueUnsignedInt = reader.GetUInt32();
          break;

        case "minValueQuantity":
          MinValueQuantity = new fhirCsR4.Models.Quantity();
          MinValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "mustSupport":
          MustSupport = reader.GetBoolean();
          break;

        case "orderMeaning":
          OrderMeaning = reader.GetString();
          break;

        case "_orderMeaning":
          _OrderMeaning = new fhirCsR4.Models.Element();
          _OrderMeaning.DeserializeJson(ref reader, options);
          break;

        case "path":
          Path = reader.GetString();
          break;

        case "_path":
          _Path = new fhirCsR4.Models.Element();
          _Path.DeserializeJson(ref reader, options);
          break;

        case "patternBase64Binary":
          PatternBase64Binary = System.Convert.FromBase64String(reader.GetString());
          break;

        case "patternBoolean":
          PatternBoolean = reader.GetBoolean();
          break;

        case "patternCanonical":
          PatternCanonical = reader.GetString();
          break;

        case "_patternCanonical":
          _PatternCanonical = new fhirCsR4.Models.Element();
          _PatternCanonical.DeserializeJson(ref reader, options);
          break;

        case "patternCode":
          PatternCode = reader.GetString();
          break;

        case "_patternCode":
          _PatternCode = new fhirCsR4.Models.Element();
          _PatternCode.DeserializeJson(ref reader, options);
          break;

        case "patternDate":
          PatternDate = reader.GetString();
          break;

        case "_patternDate":
          _PatternDate = new fhirCsR4.Models.Element();
          _PatternDate.DeserializeJson(ref reader, options);
          break;

        case "patternDateTime":
          PatternDateTime = reader.GetString();
          break;

        case "_patternDateTime":
          _PatternDateTime = new fhirCsR4.Models.Element();
          _PatternDateTime.DeserializeJson(ref reader, options);
          break;

        case "patternDecimal":
          PatternDecimal = reader.GetDecimal();
          break;

        case "_patternDecimal":
          _PatternDecimal = new fhirCsR4.Models.Element();
          _PatternDecimal.DeserializeJson(ref reader, options);
          break;

        case "patternId":
          PatternId = reader.GetString();
          break;

        case "_patternId":
          _PatternId = new fhirCsR4.Models.Element();
          _PatternId.DeserializeJson(ref reader, options);
          break;

        case "patternInstant":
          PatternInstant = reader.GetString();
          break;

        case "_patternInstant":
          _PatternInstant = new fhirCsR4.Models.Element();
          _PatternInstant.DeserializeJson(ref reader, options);
          break;

        case "patternInteger":
          PatternInteger = reader.GetInt32();
          break;

        case "patternMarkdown":
          PatternMarkdown = reader.GetString();
          break;

        case "_patternMarkdown":
          _PatternMarkdown = new fhirCsR4.Models.Element();
          _PatternMarkdown.DeserializeJson(ref reader, options);
          break;

        case "patternOid":
          PatternOid = reader.GetString();
          break;

        case "_patternOid":
          _PatternOid = new fhirCsR4.Models.Element();
          _PatternOid.DeserializeJson(ref reader, options);
          break;

        case "patternPositiveInt":
          PatternPositiveInt = reader.GetUInt32();
          break;

        case "patternString":
          PatternString = reader.GetString();
          break;

        case "_patternString":
          _PatternString = new fhirCsR4.Models.Element();
          _PatternString.DeserializeJson(ref reader, options);
          break;

        case "patternTime":
          PatternTime = reader.GetString();
          break;

        case "_patternTime":
          _PatternTime = new fhirCsR4.Models.Element();
          _PatternTime.DeserializeJson(ref reader, options);
          break;

        case "patternUnsignedInt":
          PatternUnsignedInt = reader.GetUInt32();
          break;

        case "patternUri":
          PatternUri = reader.GetString();
          break;

        case "_patternUri":
          _PatternUri = new fhirCsR4.Models.Element();
          _PatternUri.DeserializeJson(ref reader, options);
          break;

        case "patternUrl":
          PatternUrl = reader.GetString();
          break;

        case "_patternUrl":
          _PatternUrl = new fhirCsR4.Models.Element();
          _PatternUrl.DeserializeJson(ref reader, options);
          break;

        case "patternUuid":
          PatternUuid = reader.GetGuid();
          break;

        case "patternAddress":
          PatternAddress = new fhirCsR4.Models.Address();
          PatternAddress.DeserializeJson(ref reader, options);
          break;

        case "patternAge":
          PatternAge = new fhirCsR4.Models.Age();
          PatternAge.DeserializeJson(ref reader, options);
          break;

        case "patternAnnotation":
          PatternAnnotation = new fhirCsR4.Models.Annotation();
          PatternAnnotation.DeserializeJson(ref reader, options);
          break;

        case "patternAttachment":
          PatternAttachment = new fhirCsR4.Models.Attachment();
          PatternAttachment.DeserializeJson(ref reader, options);
          break;

        case "patternCodeableConcept":
          PatternCodeableConcept = new fhirCsR4.Models.CodeableConcept();
          PatternCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "patternCoding":
          PatternCoding = new fhirCsR4.Models.Coding();
          PatternCoding.DeserializeJson(ref reader, options);
          break;

        case "patternContactPoint":
          PatternContactPoint = new fhirCsR4.Models.ContactPoint();
          PatternContactPoint.DeserializeJson(ref reader, options);
          break;

        case "patternCount":
          PatternCount = new fhirCsR4.Models.Count();
          PatternCount.DeserializeJson(ref reader, options);
          break;

        case "patternDistance":
          PatternDistance = new fhirCsR4.Models.Distance();
          PatternDistance.DeserializeJson(ref reader, options);
          break;

        case "patternDuration":
          PatternDuration = new fhirCsR4.Models.Duration();
          PatternDuration.DeserializeJson(ref reader, options);
          break;

        case "patternHumanName":
          PatternHumanName = new fhirCsR4.Models.HumanName();
          PatternHumanName.DeserializeJson(ref reader, options);
          break;

        case "patternIdentifier":
          PatternIdentifier = new fhirCsR4.Models.Identifier();
          PatternIdentifier.DeserializeJson(ref reader, options);
          break;

        case "patternMoney":
          PatternMoney = new fhirCsR4.Models.Money();
          PatternMoney.DeserializeJson(ref reader, options);
          break;

        case "patternPeriod":
          PatternPeriod = new fhirCsR4.Models.Period();
          PatternPeriod.DeserializeJson(ref reader, options);
          break;

        case "patternQuantity":
          PatternQuantity = new fhirCsR4.Models.Quantity();
          PatternQuantity.DeserializeJson(ref reader, options);
          break;

        case "patternRange":
          PatternRange = new fhirCsR4.Models.Range();
          PatternRange.DeserializeJson(ref reader, options);
          break;

        case "patternRatio":
          PatternRatio = new fhirCsR4.Models.Ratio();
          PatternRatio.DeserializeJson(ref reader, options);
          break;

        case "patternReference":
          PatternReference = new fhirCsR4.Models.Reference();
          PatternReference.DeserializeJson(ref reader, options);
          break;

        case "patternSampledData":
          PatternSampledData = new fhirCsR4.Models.SampledData();
          PatternSampledData.DeserializeJson(ref reader, options);
          break;

        case "patternSignature":
          PatternSignature = new fhirCsR4.Models.Signature();
          PatternSignature.DeserializeJson(ref reader, options);
          break;

        case "patternTiming":
          PatternTiming = new fhirCsR4.Models.Timing();
          PatternTiming.DeserializeJson(ref reader, options);
          break;

        case "patternContactDetail":
          PatternContactDetail = new fhirCsR4.Models.ContactDetail();
          PatternContactDetail.DeserializeJson(ref reader, options);
          break;

        case "patternContributor":
          PatternContributor = new fhirCsR4.Models.Contributor();
          PatternContributor.DeserializeJson(ref reader, options);
          break;

        case "patternDataRequirement":
          PatternDataRequirement = new fhirCsR4.Models.DataRequirement();
          PatternDataRequirement.DeserializeJson(ref reader, options);
          break;

        case "patternExpression":
          PatternExpression = new fhirCsR4.Models.Expression();
          PatternExpression.DeserializeJson(ref reader, options);
          break;

        case "patternParameterDefinition":
          PatternParameterDefinition = new fhirCsR4.Models.ParameterDefinition();
          PatternParameterDefinition.DeserializeJson(ref reader, options);
          break;

        case "patternRelatedArtifact":
          PatternRelatedArtifact = new fhirCsR4.Models.RelatedArtifact();
          PatternRelatedArtifact.DeserializeJson(ref reader, options);
          break;

        case "patternTriggerDefinition":
          PatternTriggerDefinition = new fhirCsR4.Models.TriggerDefinition();
          PatternTriggerDefinition.DeserializeJson(ref reader, options);
          break;

        case "patternUsageContext":
          PatternUsageContext = new fhirCsR4.Models.UsageContext();
          PatternUsageContext.DeserializeJson(ref reader, options);
          break;

        case "patternDosage":
          PatternDosage = new fhirCsR4.Models.Dosage();
          PatternDosage.DeserializeJson(ref reader, options);
          break;

        case "patternMeta":
          PatternMeta = new fhirCsR4.Models.Meta();
          PatternMeta.DeserializeJson(ref reader, options);
          break;

        case "representation":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Representation = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Representation.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Representation.Count == 0)
          {
            Representation = null;
          }

          break;

        case "_representation":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Representation = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Element obj_Representation = new fhirCsR4.Models.Element();
            obj_Representation.DeserializeJson(ref reader, options);
            _Representation.Add(obj_Representation);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Representation.Count == 0)
          {
            _Representation = null;
          }

          break;

        case "requirements":
          Requirements = reader.GetString();
          break;

        case "_requirements":
          _Requirements = new fhirCsR4.Models.Element();
          _Requirements.DeserializeJson(ref reader, options);
          break;

        case "short":
          Short = reader.GetString();
          break;

        case "_short":
          _Short = new fhirCsR4.Models.Element();
          _Short.DeserializeJson(ref reader, options);
          break;

        case "sliceIsConstraining":
          SliceIsConstraining = reader.GetBoolean();
          break;

        case "sliceName":
          SliceName = reader.GetString();
          break;

        case "_sliceName":
          _SliceName = new fhirCsR4.Models.Element();
          _SliceName.DeserializeJson(ref reader, options);
          break;

        case "slicing":
          Slicing = new fhirCsR4.Models.ElementDefinitionSlicing();
          Slicing.DeserializeJson(ref reader, options);
          break;

        case "type":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Type = new List<ElementDefinitionType>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ElementDefinitionType objType = new fhirCsR4.Models.ElementDefinitionType();
            objType.DeserializeJson(ref reader, options);
            Type.Add(objType);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Type.Count == 0)
          {
            Type = null;
          }

          break;

        default:
          ((fhirCsR4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ElementDefinition.representation field
  /// </summary>
  public static class ElementDefinitionRepresentationCodes {
    public const string XMLATTR = "xmlAttr";
    public const string XMLTEXT = "xmlText";
    public const string TYPEATTR = "typeAttr";
    public const string CDATEXT = "cdaText";
    public const string XHTML = "xhtml";
  }
}

// <auto-generated />
// Built from: hl7.fhir.r4b.core version: 4.1.0
  // Option: "NAMESPACE" = "fhirCsR4"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR4.Serialization;

namespace fhirCsR4.Models
{
  /// <summary>
  /// Indicates duration, period, or point of observation from the participant's study entry.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<EvidenceVariableCharacteristicTimeFromStart>))]
  public class EvidenceVariableCharacteristicTimeFromStart : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// A short, natural language description.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// A human-readable string to clarify or explain concepts about the resource.
    /// </summary>
    public List<Annotation> Note { get; set; }
    /// <summary>
    /// Used to express the observation at a defined amount of time after the study start.
    /// </summary>
    public Quantity Quantity { get; set; }
    /// <summary>
    /// Used to express the observation within a period after the study start.
    /// </summary>
    public Range Range { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if (Quantity != null)
      {
        writer.WritePropertyName("quantity");
        Quantity.SerializeJson(writer, options);
      }

      if (Range != null)
      {
        writer.WritePropertyName("range");
        Range.SerializeJson(writer, options);
      }

      if ((Note != null) && (Note.Count != 0))
      {
        writer.WritePropertyName("note");
        writer.WriteStartArray();

        foreach (Annotation valNote in Note)
        {
          valNote.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR4.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "note":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Note = new List<Annotation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Annotation objNote = new fhirCsR4.Models.Annotation();
            objNote.DeserializeJson(ref reader, options);
            Note.Add(objNote);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Note.Count == 0)
          {
            Note = null;
          }

          break;

        case "quantity":
          Quantity = new fhirCsR4.Models.Quantity();
          Quantity.DeserializeJson(ref reader, options);
          break;

        case "range":
          Range = new fhirCsR4.Models.Range();
          Range.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Characteristics can be defined flexibly to accommodate different use cases for membership criteria, ranging from simple codes, all the way to using an expression language to express the criteria.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<EvidenceVariableCharacteristic>))]
  public class EvidenceVariableCharacteristic : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Define members of the evidence element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year).
    /// </summary>
    public Reference DefinitionReference { get; set; }
    /// <summary>
    /// Define members of the evidence element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year).
    /// </summary>
    public string DefinitionCanonical { get; set; }
    /// <summary>
    /// Extension container element for DefinitionCanonical
    /// </summary>
    public Element _DefinitionCanonical { get; set; }
    /// <summary>
    /// Define members of the evidence element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year).
    /// </summary>
    public CodeableConcept DefinitionCodeableConcept { get; set; }
    /// <summary>
    /// Define members of the evidence element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year).
    /// </summary>
    public Expression DefinitionExpression { get; set; }
    /// <summary>
    /// A short, natural language description of the characteristic that could be used to communicate the criteria to an end-user.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// Device used for determining characteristic.
    /// </summary>
    public Reference Device { get; set; }
    /// <summary>
    /// When true, members with this characteristic are excluded from the element.
    /// </summary>
    public bool? Exclude { get; set; }
    /// <summary>
    /// Indicates how elements are aggregated within the study effective period.
    /// </summary>
    public string GroupMeasure { get; set; }
    /// <summary>
    /// Extension container element for GroupMeasure
    /// </summary>
    public Element _GroupMeasure { get; set; }
    /// <summary>
    /// Method used for describing characteristic.
    /// </summary>
    public CodeableConcept Method { get; set; }
    /// <summary>
    /// Indicates duration, period, or point of observation from the participant's study entry.
    /// </summary>
    public EvidenceVariableCharacteristicTimeFromStart TimeFromStart { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if (DefinitionReference != null)
      {
        writer.WritePropertyName("definitionReference");
        DefinitionReference.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DefinitionCanonical))
      {
        writer.WriteString("definitionCanonical", (string)DefinitionCanonical!);
      }

      if (_DefinitionCanonical != null)
      {
        writer.WritePropertyName("_definitionCanonical");
        _DefinitionCanonical.SerializeJson(writer, options);
      }

      if (DefinitionCodeableConcept != null)
      {
        writer.WritePropertyName("definitionCodeableConcept");
        DefinitionCodeableConcept.SerializeJson(writer, options);
      }

      if (DefinitionExpression != null)
      {
        writer.WritePropertyName("definitionExpression");
        DefinitionExpression.SerializeJson(writer, options);
      }

      if (Method != null)
      {
        writer.WritePropertyName("method");
        Method.SerializeJson(writer, options);
      }

      if (Device != null)
      {
        writer.WritePropertyName("device");
        Device.SerializeJson(writer, options);
      }

      if (Exclude != null)
      {
        writer.WriteBoolean("exclude", (bool)Exclude!);
      }

      if (TimeFromStart != null)
      {
        writer.WritePropertyName("timeFromStart");
        TimeFromStart.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(GroupMeasure))
      {
        writer.WriteString("groupMeasure", (string)GroupMeasure!);
      }

      if (_GroupMeasure != null)
      {
        writer.WritePropertyName("_groupMeasure");
        _GroupMeasure.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "definitionReference":
          DefinitionReference = new fhirCsR4.Models.Reference();
          DefinitionReference.DeserializeJson(ref reader, options);
          break;

        case "definitionCanonical":
          DefinitionCanonical = reader.GetString();
          break;

        case "_definitionCanonical":
          _DefinitionCanonical = new fhirCsR4.Models.Element();
          _DefinitionCanonical.DeserializeJson(ref reader, options);
          break;

        case "definitionCodeableConcept":
          DefinitionCodeableConcept = new fhirCsR4.Models.CodeableConcept();
          DefinitionCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "definitionExpression":
          DefinitionExpression = new fhirCsR4.Models.Expression();
          DefinitionExpression.DeserializeJson(ref reader, options);
          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR4.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "device":
          Device = new fhirCsR4.Models.Reference();
          Device.DeserializeJson(ref reader, options);
          break;

        case "exclude":
          Exclude = reader.GetBoolean();
          break;

        case "groupMeasure":
          GroupMeasure = reader.GetString();
          break;

        case "_groupMeasure":
          _GroupMeasure = new fhirCsR4.Models.Element();
          _GroupMeasure.DeserializeJson(ref reader, options);
          break;

        case "method":
          Method = new fhirCsR4.Models.CodeableConcept();
          Method.DeserializeJson(ref reader, options);
          break;

        case "timeFromStart":
          TimeFromStart = new fhirCsR4.Models.EvidenceVariableCharacteristicTimeFromStart();
          TimeFromStart.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the EvidenceVariable.characteristic.groupMeasure field
  /// </summary>
  public static class EvidenceVariableCharacteristicGroupMeasureCodes {
    public const string MEAN = "mean";
    public const string MEDIAN = "median";
    public const string MEAN_OF_MEAN = "mean-of-mean";
    public const string MEAN_OF_MEDIAN = "mean-of-median";
    public const string MEDIAN_OF_MEAN = "median-of-mean";
    public const string MEDIAN_OF_MEDIAN = "median-of-median";
  }
  /// <summary>
  /// A grouping (or set of values) described along with other groupings to specify the set of groupings allowed for the variable.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<EvidenceVariableCategory>))]
  public class EvidenceVariableCategory : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// A human-readable title or representation of the grouping.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// Value or set of values that define the grouping.
    /// </summary>
    public CodeableConcept ValueCodeableConcept { get; set; }
    /// <summary>
    /// Value or set of values that define the grouping.
    /// </summary>
    public Quantity ValueQuantity { get; set; }
    /// <summary>
    /// Value or set of values that define the grouping.
    /// </summary>
    public Range ValueRange { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Name))
      {
        writer.WriteString("name", (string)Name!);
      }

      if (_Name != null)
      {
        writer.WritePropertyName("_name");
        _Name.SerializeJson(writer, options);
      }

      if (ValueCodeableConcept != null)
      {
        writer.WritePropertyName("valueCodeableConcept");
        ValueCodeableConcept.SerializeJson(writer, options);
      }

      if (ValueQuantity != null)
      {
        writer.WritePropertyName("valueQuantity");
        ValueQuantity.SerializeJson(writer, options);
      }

      if (ValueRange != null)
      {
        writer.WritePropertyName("valueRange");
        ValueRange.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new fhirCsR4.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        case "valueCodeableConcept":
          ValueCodeableConcept = new fhirCsR4.Models.CodeableConcept();
          ValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "valueQuantity":
          ValueQuantity = new fhirCsR4.Models.Quantity();
          ValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "valueRange":
          ValueRange = new fhirCsR4.Models.Range();
          ValueRange.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The EvidenceVariable resource describes an element that knowledge (Evidence) is about.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<EvidenceVariable>))]
  public class EvidenceVariable : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "EvidenceVariable";
    /// <summary>
    /// True if the actual variable measured, false if a conceptual representation of the intended variable.
    /// </summary>
    public bool? Actual { get; set; }
    /// <summary>
    /// Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
    /// </summary>
    public List<ContactDetail> Author { get; set; }
    /// <summary>
    /// A grouping (or set of values) described along with other groupings to specify the set of groupings allowed for the variable.
    /// </summary>
    public List<EvidenceVariableCategory> Category { get; set; }
    /// <summary>
    /// Characteristics can be defined flexibly to accommodate different use cases for membership criteria, ranging from simple codes, all the way to using an expression language to express the criteria.
    /// </summary>
    public List<EvidenceVariableCharacteristic> Characteristic { get; set; }
    /// <summary>
    /// Used to specify if two or more characteristics are combined with OR or AND.
    /// </summary>
    public string CharacteristicCombination { get; set; }
    /// <summary>
    /// Extension container element for CharacteristicCombination
    /// </summary>
    public Element _CharacteristicCombination { get; set; }
    /// <summary>
    /// Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
    /// </summary>
    public List<ContactDetail> Contact { get; set; }
    /// <summary>
    /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the evidence variable. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
    /// </summary>
    public string Date { get; set; }
    /// <summary>
    /// Extension container element for Date
    /// </summary>
    public Element _Date { get; set; }
    /// <summary>
    /// This description can be used to capture details such as why the evidence variable was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the evidence variable as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the evidence variable is presumed to be the predominant language in the place the evidence variable was created).
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
    /// </summary>
    public List<ContactDetail> Editor { get; set; }
    /// <summary>
    /// Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
    /// </summary>
    public List<ContactDetail> Endorser { get; set; }
    /// <summary>
    /// Used for an outcome to classify.
    /// </summary>
    public string Handling { get; set; }
    /// <summary>
    /// Extension container element for Handling
    /// </summary>
    public Element _Handling { get; set; }
    /// <summary>
    /// Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this evidence variable outside of FHIR, where it is not possible to use the logical URI.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// A human-readable string to clarify or explain concepts about the resource.
    /// </summary>
    public List<Annotation> Note { get; set; }
    /// <summary>
    /// Usually an organization but may be an individual. The publisher (or steward) of the evidence variable is the organization or individual primarily responsible for the maintenance and upkeep of the evidence variable. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the evidence variable. This item SHOULD be populated unless the information is available from context.
    /// </summary>
    public string Publisher { get; set; }
    /// <summary>
    /// Extension container element for Publisher
    /// </summary>
    public Element _Publisher { get; set; }
    /// <summary>
    /// Each related artifact is either an attachment, or a reference to another resource, but not both.
    /// </summary>
    public List<RelatedArtifact> RelatedArtifact { get; set; }
    /// <summary>
    /// Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
    /// </summary>
    public List<ContactDetail> Reviewer { get; set; }
    /// <summary>
    /// The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    /// </summary>
    public string ShortTitle { get; set; }
    /// <summary>
    /// Extension container element for ShortTitle
    /// </summary>
    public Element _ShortTitle { get; set; }
    /// <summary>
    /// Allows filtering of evidence variables that are appropriate for use versus not.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// An explanatory or alternate title for the EvidenceVariable giving additional information about its content.
    /// </summary>
    public string Subtitle { get; set; }
    /// <summary>
    /// Extension container element for Subtitle
    /// </summary>
    public Element _Subtitle { get; set; }
    /// <summary>
    /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
    /// </summary>
    public string Title { get; set; }
    /// <summary>
    /// Extension container element for Title
    /// </summary>
    public Element _Title { get; set; }
    /// <summary>
    /// Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
    /// The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions). 
    /// In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
    /// </summary>
    public List<UsageContext> UseContext { get; set; }
    /// <summary>
    /// There may be different evidence variable instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the evidence variable with the format [url]|[version].
    /// </summary>
    public string Version { get; set; }
    /// <summary>
    /// Extension container element for Version
    /// </summary>
    public Element _Version { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR4.Models.DomainResource)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Url))
      {
        writer.WriteString("url", (string)Url!);
      }

      if (_Url != null)
      {
        writer.WritePropertyName("_url");
        _Url.SerializeJson(writer, options);
      }

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Version))
      {
        writer.WriteString("version", (string)Version!);
      }

      if (_Version != null)
      {
        writer.WritePropertyName("_version");
        _Version.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Name))
      {
        writer.WriteString("name", (string)Name!);
      }

      if (_Name != null)
      {
        writer.WritePropertyName("_name");
        _Name.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Title))
      {
        writer.WriteString("title", (string)Title!);
      }

      if (_Title != null)
      {
        writer.WritePropertyName("_title");
        _Title.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ShortTitle))
      {
        writer.WriteString("shortTitle", (string)ShortTitle!);
      }

      if (_ShortTitle != null)
      {
        writer.WritePropertyName("_shortTitle");
        _ShortTitle.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Subtitle))
      {
        writer.WriteString("subtitle", (string)Subtitle!);
      }

      if (_Subtitle != null)
      {
        writer.WritePropertyName("_subtitle");
        _Subtitle.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Date))
      {
        writer.WriteString("date", (string)Date!);
      }

      if (_Date != null)
      {
        writer.WritePropertyName("_date");
        _Date.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if ((Note != null) && (Note.Count != 0))
      {
        writer.WritePropertyName("note");
        writer.WriteStartArray();

        foreach (Annotation valNote in Note)
        {
          valNote.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((UseContext != null) && (UseContext.Count != 0))
      {
        writer.WritePropertyName("useContext");
        writer.WriteStartArray();

        foreach (UsageContext valUseContext in UseContext)
        {
          valUseContext.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Publisher))
      {
        writer.WriteString("publisher", (string)Publisher!);
      }

      if (_Publisher != null)
      {
        writer.WritePropertyName("_publisher");
        _Publisher.SerializeJson(writer, options);
      }

      if ((Contact != null) && (Contact.Count != 0))
      {
        writer.WritePropertyName("contact");
        writer.WriteStartArray();

        foreach (ContactDetail valContact in Contact)
        {
          valContact.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Author != null) && (Author.Count != 0))
      {
        writer.WritePropertyName("author");
        writer.WriteStartArray();

        foreach (ContactDetail valAuthor in Author)
        {
          valAuthor.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Editor != null) && (Editor.Count != 0))
      {
        writer.WritePropertyName("editor");
        writer.WriteStartArray();

        foreach (ContactDetail valEditor in Editor)
        {
          valEditor.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Reviewer != null) && (Reviewer.Count != 0))
      {
        writer.WritePropertyName("reviewer");
        writer.WriteStartArray();

        foreach (ContactDetail valReviewer in Reviewer)
        {
          valReviewer.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Endorser != null) && (Endorser.Count != 0))
      {
        writer.WritePropertyName("endorser");
        writer.WriteStartArray();

        foreach (ContactDetail valEndorser in Endorser)
        {
          valEndorser.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((RelatedArtifact != null) && (RelatedArtifact.Count != 0))
      {
        writer.WritePropertyName("relatedArtifact");
        writer.WriteStartArray();

        foreach (RelatedArtifact valRelatedArtifact in RelatedArtifact)
        {
          valRelatedArtifact.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Actual != null)
      {
        writer.WriteBoolean("actual", (bool)Actual!);
      }

      if (!string.IsNullOrEmpty(CharacteristicCombination))
      {
        writer.WriteString("characteristicCombination", (string)CharacteristicCombination!);
      }

      if (_CharacteristicCombination != null)
      {
        writer.WritePropertyName("_characteristicCombination");
        _CharacteristicCombination.SerializeJson(writer, options);
      }

      if ((Characteristic != null) && (Characteristic.Count != 0))
      {
        writer.WritePropertyName("characteristic");
        writer.WriteStartArray();

        foreach (EvidenceVariableCharacteristic valCharacteristic in Characteristic)
        {
          valCharacteristic.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Handling))
      {
        writer.WriteString("handling", (string)Handling!);
      }

      if (_Handling != null)
      {
        writer.WritePropertyName("_handling");
        _Handling.SerializeJson(writer, options);
      }

      if ((Category != null) && (Category.Count != 0))
      {
        writer.WritePropertyName("category");
        writer.WriteStartArray();

        foreach (EvidenceVariableCategory valCategory in Category)
        {
          valCategory.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "actual":
          Actual = reader.GetBoolean();
          break;

        case "author":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Author = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ContactDetail objAuthor = new fhirCsR4.Models.ContactDetail();
            objAuthor.DeserializeJson(ref reader, options);
            Author.Add(objAuthor);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Author.Count == 0)
          {
            Author = null;
          }

          break;

        case "category":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Category = new List<EvidenceVariableCategory>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.EvidenceVariableCategory objCategory = new fhirCsR4.Models.EvidenceVariableCategory();
            objCategory.DeserializeJson(ref reader, options);
            Category.Add(objCategory);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Category.Count == 0)
          {
            Category = null;
          }

          break;

        case "characteristic":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Characteristic = new List<EvidenceVariableCharacteristic>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.EvidenceVariableCharacteristic objCharacteristic = new fhirCsR4.Models.EvidenceVariableCharacteristic();
            objCharacteristic.DeserializeJson(ref reader, options);
            Characteristic.Add(objCharacteristic);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Characteristic.Count == 0)
          {
            Characteristic = null;
          }

          break;

        case "characteristicCombination":
          CharacteristicCombination = reader.GetString();
          break;

        case "_characteristicCombination":
          _CharacteristicCombination = new fhirCsR4.Models.Element();
          _CharacteristicCombination.DeserializeJson(ref reader, options);
          break;

        case "contact":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Contact = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ContactDetail objContact = new fhirCsR4.Models.ContactDetail();
            objContact.DeserializeJson(ref reader, options);
            Contact.Add(objContact);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Contact.Count == 0)
          {
            Contact = null;
          }

          break;

        case "date":
          Date = reader.GetString();
          break;

        case "_date":
          _Date = new fhirCsR4.Models.Element();
          _Date.DeserializeJson(ref reader, options);
          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR4.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "editor":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Editor = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ContactDetail objEditor = new fhirCsR4.Models.ContactDetail();
            objEditor.DeserializeJson(ref reader, options);
            Editor.Add(objEditor);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Editor.Count == 0)
          {
            Editor = null;
          }

          break;

        case "endorser":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Endorser = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ContactDetail objEndorser = new fhirCsR4.Models.ContactDetail();
            objEndorser.DeserializeJson(ref reader, options);
            Endorser.Add(objEndorser);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Endorser.Count == 0)
          {
            Endorser = null;
          }

          break;

        case "handling":
          Handling = reader.GetString();
          break;

        case "_handling":
          _Handling = new fhirCsR4.Models.Element();
          _Handling.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Identifier objIdentifier = new fhirCsR4.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new fhirCsR4.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        case "note":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Note = new List<Annotation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Annotation objNote = new fhirCsR4.Models.Annotation();
            objNote.DeserializeJson(ref reader, options);
            Note.Add(objNote);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Note.Count == 0)
          {
            Note = null;
          }

          break;

        case "publisher":
          Publisher = reader.GetString();
          break;

        case "_publisher":
          _Publisher = new fhirCsR4.Models.Element();
          _Publisher.DeserializeJson(ref reader, options);
          break;

        case "relatedArtifact":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          RelatedArtifact = new List<RelatedArtifact>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.RelatedArtifact objRelatedArtifact = new fhirCsR4.Models.RelatedArtifact();
            objRelatedArtifact.DeserializeJson(ref reader, options);
            RelatedArtifact.Add(objRelatedArtifact);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (RelatedArtifact.Count == 0)
          {
            RelatedArtifact = null;
          }

          break;

        case "reviewer":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Reviewer = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ContactDetail objReviewer = new fhirCsR4.Models.ContactDetail();
            objReviewer.DeserializeJson(ref reader, options);
            Reviewer.Add(objReviewer);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Reviewer.Count == 0)
          {
            Reviewer = null;
          }

          break;

        case "shortTitle":
          ShortTitle = reader.GetString();
          break;

        case "_shortTitle":
          _ShortTitle = new fhirCsR4.Models.Element();
          _ShortTitle.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR4.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "subtitle":
          Subtitle = reader.GetString();
          break;

        case "_subtitle":
          _Subtitle = new fhirCsR4.Models.Element();
          _Subtitle.DeserializeJson(ref reader, options);
          break;

        case "title":
          Title = reader.GetString();
          break;

        case "_title":
          _Title = new fhirCsR4.Models.Element();
          _Title.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new fhirCsR4.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        case "useContext":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          UseContext = new List<UsageContext>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.UsageContext objUseContext = new fhirCsR4.Models.UsageContext();
            objUseContext.DeserializeJson(ref reader, options);
            UseContext.Add(objUseContext);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (UseContext.Count == 0)
          {
            UseContext = null;
          }

          break;

        case "version":
          Version = reader.GetString();
          break;

        case "_version":
          _Version = new fhirCsR4.Models.Element();
          _Version.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the EvidenceVariable.characteristicCombination field
  /// </summary>
  public static class EvidenceVariableCharacteristicCombinationCodes {
    public const string INTERSECTION = "intersection";
    public const string UNION = "union";
  }
  /// <summary>
  /// Code Values for the EvidenceVariable.handling field
  /// </summary>
  public static class EvidenceVariableHandlingCodes {
    public const string CONTINUOUS = "continuous";
    public const string DICHOTOMOUS = "dichotomous";
    public const string ORDINAL = "ordinal";
    public const string POLYCHOTOMOUS = "polychotomous";
  }
  /// <summary>
  /// Code Values for the EvidenceVariable.status field
  /// </summary>
  public static class EvidenceVariableStatusCodes {
    public const string DRAFT = "draft";
    public const string ACTIVE = "active";
    public const string RETIRED = "retired";
    public const string UNKNOWN = "unknown";
  }
}

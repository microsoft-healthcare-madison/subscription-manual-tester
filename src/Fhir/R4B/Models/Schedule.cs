// <auto-generated />
// Built from: hl7.fhir.r4b.core version: 4.1.0
  // Option: "NAMESPACE" = "fhirCsR4"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR4.Serialization;

namespace fhirCsR4.Models
{
  /// <summary>
  /// A container for slots of time that may be available for booking appointments.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<Schedule>))]
  public class Schedule : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "Schedule";
    /// <summary>
    /// This element is labeled as a modifier because it may be used to mark that the resource was created in error.
    /// </summary>
    public bool? Active { get; set; }
    /// <summary>
    /// The capacity to support multiple referenced resource types should be used in cases where the specific resources themselves cannot be scheduled without the other, and thus only make sense to the system exposing them as a group. Common examples of this are where the combination of a practitioner and a room (Location) are always required by a system.
    /// </summary>
    public List<Reference> Actor { get; set; }
    /// <summary>
    /// Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
    /// </summary>
    public string Comment { get; set; }
    /// <summary>
    /// Extension container element for Comment
    /// </summary>
    public Element _Comment { get; set; }
    /// <summary>
    /// External Ids for this item.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates.
    /// </summary>
    public Period PlanningHorizon { get; set; }
    /// <summary>
    /// A broad categorization of the service that is to be performed during this appointment.
    /// </summary>
    public List<CodeableConcept> ServiceCategory { get; set; }
    /// <summary>
    /// The specific service that is to be performed during this appointment.
    /// </summary>
    public List<CodeableConcept> ServiceType { get; set; }
    /// <summary>
    /// The specialty of a practitioner that would be required to perform the service requested in this appointment.
    /// </summary>
    public List<CodeableConcept> Specialty { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR4.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Active != null)
      {
        writer.WriteBoolean("active", (bool)Active!);
      }

      if ((ServiceCategory != null) && (ServiceCategory.Count != 0))
      {
        writer.WritePropertyName("serviceCategory");
        writer.WriteStartArray();

        foreach (CodeableConcept valServiceCategory in ServiceCategory)
        {
          valServiceCategory.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ServiceType != null) && (ServiceType.Count != 0))
      {
        writer.WritePropertyName("serviceType");
        writer.WriteStartArray();

        foreach (CodeableConcept valServiceType in ServiceType)
        {
          valServiceType.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Specialty != null) && (Specialty.Count != 0))
      {
        writer.WritePropertyName("specialty");
        writer.WriteStartArray();

        foreach (CodeableConcept valSpecialty in Specialty)
        {
          valSpecialty.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Actor != null) && (Actor.Count != 0))
      {
        writer.WritePropertyName("actor");
        writer.WriteStartArray();

        foreach (Reference valActor in Actor)
        {
          valActor.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (PlanningHorizon != null)
      {
        writer.WritePropertyName("planningHorizon");
        PlanningHorizon.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Comment))
      {
        writer.WriteString("comment", (string)Comment!);
      }

      if (_Comment != null)
      {
        writer.WritePropertyName("_comment");
        _Comment.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "active":
          Active = reader.GetBoolean();
          break;

        case "actor":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Actor = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Reference objActor = new fhirCsR4.Models.Reference();
            objActor.DeserializeJson(ref reader, options);
            Actor.Add(objActor);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Actor.Count == 0)
          {
            Actor = null;
          }

          break;

        case "comment":
          Comment = reader.GetString();
          break;

        case "_comment":
          _Comment = new fhirCsR4.Models.Element();
          _Comment.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Identifier objIdentifier = new fhirCsR4.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "planningHorizon":
          PlanningHorizon = new fhirCsR4.Models.Period();
          PlanningHorizon.DeserializeJson(ref reader, options);
          break;

        case "serviceCategory":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ServiceCategory = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.CodeableConcept objServiceCategory = new fhirCsR4.Models.CodeableConcept();
            objServiceCategory.DeserializeJson(ref reader, options);
            ServiceCategory.Add(objServiceCategory);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ServiceCategory.Count == 0)
          {
            ServiceCategory = null;
          }

          break;

        case "serviceType":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ServiceType = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.CodeableConcept objServiceType = new fhirCsR4.Models.CodeableConcept();
            objServiceType.DeserializeJson(ref reader, options);
            ServiceType.Add(objServiceType);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ServiceType.Count == 0)
          {
            ServiceType = null;
          }

          break;

        case "specialty":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Specialty = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.CodeableConcept objSpecialty = new fhirCsR4.Models.CodeableConcept();
            objSpecialty.DeserializeJson(ref reader, options);
            Specialty.Add(objSpecialty);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Specialty.Count == 0)
          {
            Specialty = null;
          }

          break;

        default:
          ((fhirCsR4.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
}

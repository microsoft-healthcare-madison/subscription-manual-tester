// <auto-generated />
// Built from: hl7.fhir.r4b.core version: 4.1.0
  // Option: "NAMESPACE" = "fhirCsR4"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR4.Serialization;

namespace fhirCsR4.Models
{
  /// <summary>
  /// Characteristic.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<EvidenceReportSubjectCharacteristic>))]
  public class EvidenceReportSubjectCharacteristic : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Example 1 is a Citation. Example 2 is a type of outcome. Example 3 is a specific outcome.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// Is used to express not the characteristic.
    /// </summary>
    public bool? Exclude { get; set; }
    /// <summary>
    /// Timeframe for the characteristic.
    /// </summary>
    public Period Period { get; set; }
    /// <summary>
    /// Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
    /// </summary>
    public Reference ValueReference { get; set; }
    /// <summary>
    /// Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
    /// </summary>
    public CodeableConcept ValueCodeableConcept { get; set; }
    /// <summary>
    /// Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
    /// </summary>
    public bool? ValueBoolean { get; set; }
    /// <summary>
    /// Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
    /// </summary>
    public Quantity ValueQuantity { get; set; }
    /// <summary>
    /// Example 1 is Citation #37. Example 2 is selecting clinical outcomes. Example 3 is 1-year mortality.
    /// </summary>
    public Range ValueRange { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if (ValueReference != null)
      {
        writer.WritePropertyName("valueReference");
        ValueReference.SerializeJson(writer, options);
      }

      if (ValueCodeableConcept != null)
      {
        writer.WritePropertyName("valueCodeableConcept");
        ValueCodeableConcept.SerializeJson(writer, options);
      }

      if (ValueBoolean != null)
      {
        writer.WriteBoolean("valueBoolean", (bool)ValueBoolean!);
      }

      if (ValueQuantity != null)
      {
        writer.WritePropertyName("valueQuantity");
        ValueQuantity.SerializeJson(writer, options);
      }

      if (ValueRange != null)
      {
        writer.WritePropertyName("valueRange");
        ValueRange.SerializeJson(writer, options);
      }

      if (Exclude != null)
      {
        writer.WriteBoolean("exclude", (bool)Exclude!);
      }

      if (Period != null)
      {
        writer.WritePropertyName("period");
        Period.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = new fhirCsR4.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "exclude":
          Exclude = reader.GetBoolean();
          break;

        case "period":
          Period = new fhirCsR4.Models.Period();
          Period.DeserializeJson(ref reader, options);
          break;

        case "valueReference":
          ValueReference = new fhirCsR4.Models.Reference();
          ValueReference.DeserializeJson(ref reader, options);
          break;

        case "valueCodeableConcept":
          ValueCodeableConcept = new fhirCsR4.Models.CodeableConcept();
          ValueCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "valueBoolean":
          ValueBoolean = reader.GetBoolean();
          break;

        case "valueQuantity":
          ValueQuantity = new fhirCsR4.Models.Quantity();
          ValueQuantity.DeserializeJson(ref reader, options);
          break;

        case "valueRange":
          ValueRange = new fhirCsR4.Models.Range();
          ValueRange.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// May be used as an expression for search queries and search results
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<EvidenceReportSubject>))]
  public class EvidenceReportSubject : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Characteristic.
    /// </summary>
    public List<EvidenceReportSubjectCharacteristic> Characteristic { get; set; }
    /// <summary>
    /// Used for general notes and annotations not coded elsewhere.
    /// </summary>
    public List<Annotation> Note { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if ((Characteristic != null) && (Characteristic.Count != 0))
      {
        writer.WritePropertyName("characteristic");
        writer.WriteStartArray();

        foreach (EvidenceReportSubjectCharacteristic valCharacteristic in Characteristic)
        {
          valCharacteristic.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Note != null) && (Note.Count != 0))
      {
        writer.WritePropertyName("note");
        writer.WriteStartArray();

        foreach (Annotation valNote in Note)
        {
          valNote.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "characteristic":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Characteristic = new List<EvidenceReportSubjectCharacteristic>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.EvidenceReportSubjectCharacteristic objCharacteristic = new fhirCsR4.Models.EvidenceReportSubjectCharacteristic();
            objCharacteristic.DeserializeJson(ref reader, options);
            Characteristic.Add(objCharacteristic);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Characteristic.Count == 0)
          {
            Characteristic = null;
          }

          break;

        case "note":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Note = new List<Annotation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Annotation objNote = new fhirCsR4.Models.Annotation();
            objNote.DeserializeJson(ref reader, options);
            Note.Add(objNote);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Note.Count == 0)
          {
            Note = null;
          }

          break;

        default:
          ((fhirCsR4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A document is a version specific composition.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<EvidenceReportRelatesTo>))]
  public class EvidenceReportRelatesTo : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// If this document appends another document, then the document cannot be fully understood without also accessing the referenced document.
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// The target composition/document of this relationship.
    /// </summary>
    public Identifier TargetIdentifier { get; set; }
    /// <summary>
    /// The target composition/document of this relationship.
    /// </summary>
    public Reference TargetReference { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Code))
      {
        writer.WriteString("code", (string)Code!);
      }

      if (_Code != null)
      {
        writer.WritePropertyName("_code");
        _Code.SerializeJson(writer, options);
      }

      if (TargetIdentifier != null)
      {
        writer.WritePropertyName("targetIdentifier");
        TargetIdentifier.SerializeJson(writer, options);
      }

      if (TargetReference != null)
      {
        writer.WritePropertyName("targetReference");
        TargetReference.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new fhirCsR4.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "targetIdentifier":
          TargetIdentifier = new fhirCsR4.Models.Identifier();
          TargetIdentifier.DeserializeJson(ref reader, options);
          break;

        case "targetReference":
          TargetReference = new fhirCsR4.Models.Reference();
          TargetReference.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the EvidenceReport.relatesTo.code field
  /// </summary>
  public static class EvidenceReportRelatesToCodeCodes {
    public const string REPLACES = "replaces";
    public const string AMENDS = "amends";
    public const string APPENDS = "appends";
    public const string TRANSFORMS = "transforms";
    public const string REPLACEDWITH = "replacedWith";
    public const string AMENDEDWITH = "amendedWith";
    public const string APPENDEDWITH = "appendedWith";
    public const string TRANSFORMEDWITH = "transformedWith";
  }
  /// <summary>
  /// The root of the sections that make up the composition.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<EvidenceReportSection>))]
  public class EvidenceReportSection : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Identifies who is responsible for the information in this section, not necessarily who typed it in.
    /// </summary>
    public List<Reference> Author { get; set; }
    /// <summary>
    /// The various reasons for an empty section make a significant interpretation to its interpretation. Note that this code is for use when the entire section content has been suppressed, and not for when individual items are omitted - implementers may consider using a text note or a flag on an entry in these cases.
    /// </summary>
    public CodeableConcept EmptyReason { get; set; }
    /// <summary>
    /// Specifies any type of classification of the evidence report.
    /// </summary>
    public List<CodeableConcept> EntryClassifier { get; set; }
    /// <summary>
    /// Quantity as content.
    /// </summary>
    public List<Quantity> EntryQuantity { get; set; }
    /// <summary>
    /// If there are no entries in the list, an emptyReason SHOULD be provided.
    /// </summary>
    public List<Reference> EntryReference { get; set; }
    /// <summary>
    /// The code identifies the section for an automated processor of the document. This is particularly relevant when using profiles to control the structure of the document.   
    /// If the section has content (instead of sub-sections), the section.code does not change the meaning or interpretation of the resource that is the content of the section in the comments for the section.code.
    /// </summary>
    public CodeableConcept Focus { get; set; }
    /// <summary>
    /// A definitional Resource identifying the kind of content contained within the section. This should be consistent with the section title.
    /// </summary>
    public Reference FocusReference { get; set; }
    /// <summary>
    /// This element is labeled as a modifier because a change list must not be misunderstood as a complete list.
    /// </summary>
    public string Mode { get; set; }
    /// <summary>
    /// Extension container element for Mode
    /// </summary>
    public Element _Mode { get; set; }
    /// <summary>
    /// Applications SHOULD render ordered lists in the order provided, but MAY allow users to re-order based on their own preferences as well. If there is no order specified, the order is unknown, though there may still be some order.
    /// </summary>
    public CodeableConcept OrderedBy { get; set; }
    /// <summary>
    /// Nested sections are primarily used to help human readers navigate to particular portions of the document.
    /// </summary>
    public List<EvidenceReportSection> Section { get; set; }
    /// <summary>
    /// Document profiles may define what content should be represented in the narrative.
    /// </summary>
    public Narrative Text { get; set; }
    /// <summary>
    /// The title identifies the section for a human reader. The title must be consistent with the narrative of the resource that is the target of the section.content reference. Generally, sections SHOULD have titles, but in some documents, it is unnecessary or inappropriate. Typically, this is where a section has subsections that have their own adequately distinguishing title,  or documents that only have a single section.
    /// </summary>
    public string Title { get; set; }
    /// <summary>
    /// Extension container element for Title
    /// </summary>
    public Element _Title { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Title))
      {
        writer.WriteString("title", (string)Title!);
      }

      if (_Title != null)
      {
        writer.WritePropertyName("_title");
        _Title.SerializeJson(writer, options);
      }

      if (Focus != null)
      {
        writer.WritePropertyName("focus");
        Focus.SerializeJson(writer, options);
      }

      if (FocusReference != null)
      {
        writer.WritePropertyName("focusReference");
        FocusReference.SerializeJson(writer, options);
      }

      if ((Author != null) && (Author.Count != 0))
      {
        writer.WritePropertyName("author");
        writer.WriteStartArray();

        foreach (Reference valAuthor in Author)
        {
          valAuthor.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Text != null)
      {
        writer.WritePropertyName("text");
        Text.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Mode))
      {
        writer.WriteString("mode", (string)Mode!);
      }

      if (_Mode != null)
      {
        writer.WritePropertyName("_mode");
        _Mode.SerializeJson(writer, options);
      }

      if (OrderedBy != null)
      {
        writer.WritePropertyName("orderedBy");
        OrderedBy.SerializeJson(writer, options);
      }

      if ((EntryClassifier != null) && (EntryClassifier.Count != 0))
      {
        writer.WritePropertyName("entryClassifier");
        writer.WriteStartArray();

        foreach (CodeableConcept valEntryClassifier in EntryClassifier)
        {
          valEntryClassifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((EntryReference != null) && (EntryReference.Count != 0))
      {
        writer.WritePropertyName("entryReference");
        writer.WriteStartArray();

        foreach (Reference valEntryReference in EntryReference)
        {
          valEntryReference.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((EntryQuantity != null) && (EntryQuantity.Count != 0))
      {
        writer.WritePropertyName("entryQuantity");
        writer.WriteStartArray();

        foreach (Quantity valEntryQuantity in EntryQuantity)
        {
          valEntryQuantity.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (EmptyReason != null)
      {
        writer.WritePropertyName("emptyReason");
        EmptyReason.SerializeJson(writer, options);
      }

      if ((Section != null) && (Section.Count != 0))
      {
        writer.WritePropertyName("section");
        writer.WriteStartArray();

        foreach (EvidenceReportSection valSection in Section)
        {
          valSection.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "author":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Author = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Reference objAuthor = new fhirCsR4.Models.Reference();
            objAuthor.DeserializeJson(ref reader, options);
            Author.Add(objAuthor);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Author.Count == 0)
          {
            Author = null;
          }

          break;

        case "emptyReason":
          EmptyReason = new fhirCsR4.Models.CodeableConcept();
          EmptyReason.DeserializeJson(ref reader, options);
          break;

        case "entryClassifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          EntryClassifier = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.CodeableConcept objEntryClassifier = new fhirCsR4.Models.CodeableConcept();
            objEntryClassifier.DeserializeJson(ref reader, options);
            EntryClassifier.Add(objEntryClassifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (EntryClassifier.Count == 0)
          {
            EntryClassifier = null;
          }

          break;

        case "entryQuantity":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          EntryQuantity = new List<Quantity>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Quantity objEntryQuantity = new fhirCsR4.Models.Quantity();
            objEntryQuantity.DeserializeJson(ref reader, options);
            EntryQuantity.Add(objEntryQuantity);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (EntryQuantity.Count == 0)
          {
            EntryQuantity = null;
          }

          break;

        case "entryReference":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          EntryReference = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Reference objEntryReference = new fhirCsR4.Models.Reference();
            objEntryReference.DeserializeJson(ref reader, options);
            EntryReference.Add(objEntryReference);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (EntryReference.Count == 0)
          {
            EntryReference = null;
          }

          break;

        case "focus":
          Focus = new fhirCsR4.Models.CodeableConcept();
          Focus.DeserializeJson(ref reader, options);
          break;

        case "focusReference":
          FocusReference = new fhirCsR4.Models.Reference();
          FocusReference.DeserializeJson(ref reader, options);
          break;

        case "mode":
          Mode = reader.GetString();
          break;

        case "_mode":
          _Mode = new fhirCsR4.Models.Element();
          _Mode.DeserializeJson(ref reader, options);
          break;

        case "orderedBy":
          OrderedBy = new fhirCsR4.Models.CodeableConcept();
          OrderedBy.DeserializeJson(ref reader, options);
          break;

        case "section":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Section = new List<EvidenceReportSection>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.EvidenceReportSection objSection = new fhirCsR4.Models.EvidenceReportSection();
            objSection.DeserializeJson(ref reader, options);
            Section.Add(objSection);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Section.Count == 0)
          {
            Section = null;
          }

          break;

        case "text":
          Text = new fhirCsR4.Models.Narrative();
          Text.DeserializeJson(ref reader, options);
          break;

        case "title":
          Title = reader.GetString();
          break;

        case "_title":
          _Title = new fhirCsR4.Models.Element();
          _Title.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the EvidenceReport.section.mode field
  /// </summary>
  public static class EvidenceReportSectionModeCodes {
    public const string WORKING = "working";
    public const string SNAPSHOT = "snapshot";
    public const string CHANGES = "changes";
  }
  /// <summary>
  /// The EvidenceReport Resource is a specialized container for a collection of resources and codable concepts, adapted to support compositions of Evidence, EvidenceVariable, and Citation resources and related concepts.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4.Serialization.JsonStreamComponentConverter<EvidenceReport>))]
  public class EvidenceReport : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "EvidenceReport";
    /// <summary>
    /// Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
    /// </summary>
    public List<ContactDetail> Author { get; set; }
    /// <summary>
    /// used for reports for which external citation is expected, such as use in support of scholarly publications.
    /// </summary>
    public Reference CiteAsReference { get; set; }
    /// <summary>
    /// used for reports for which external citation is expected, such as use in support of scholarly publications.
    /// </summary>
    public string CiteAsMarkdown { get; set; }
    /// <summary>
    /// Extension container element for CiteAsMarkdown
    /// </summary>
    public Element _CiteAsMarkdown { get; set; }
    /// <summary>
    /// Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
    /// </summary>
    public List<ContactDetail> Contact { get; set; }
    /// <summary>
    /// Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
    /// </summary>
    public List<ContactDetail> Editor { get; set; }
    /// <summary>
    /// Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
    /// </summary>
    public List<ContactDetail> Endorser { get; set; }
    /// <summary>
    /// This element will contain unique identifiers that support de-duplication of EvidenceReports. This identifier can be valid for only one EvidenceReport resource.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Used for footnotes and annotations.
    /// </summary>
    public List<Annotation> Note { get; set; }
    /// <summary>
    /// Usually an organization but may be an individual. The publisher (or steward) of the evidence report is the organization or individual primarily responsible for the maintenance and upkeep of the evidence report. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the evidence report. This item SHOULD be populated unless the information is available from context.
    /// </summary>
    public string Publisher { get; set; }
    /// <summary>
    /// Extension container element for Publisher
    /// </summary>
    public Element _Publisher { get; set; }
    /// <summary>
    /// Link, description or reference to artifact associated with the report.
    /// </summary>
    public List<RelatedArtifact> RelatedArtifact { get; set; }
    /// <summary>
    /// May include trial registry identifiers, e.g. NCT04372602 from clinicaltrials.gov. This identifier can be valid for multiple EvidenceReport resources.
    /// </summary>
    public List<Identifier> RelatedIdentifier { get; set; }
    /// <summary>
    /// A document is a version specific composition.
    /// </summary>
    public List<EvidenceReportRelatesTo> RelatesTo { get; set; }
    /// <summary>
    /// Extensions to ContactDetail include: contactReference, contactAddress, and contributionTime (Details at: http://build.fhir.org/clinicalreasoning-module.html).
    /// </summary>
    public List<ContactDetail> Reviewer { get; set; }
    /// <summary>
    /// The root of the sections that make up the composition.
    /// </summary>
    public List<EvidenceReportSection> Section { get; set; }
    /// <summary>
    /// Allows filtering of summaries that are appropriate for use versus not.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// May be used as an expression for search queries and search results
    /// </summary>
    public EvidenceReportSubject Subject { get; set; }
    /// <summary>
    /// Specifies the kind of report, such as grouping of classifiers, search results, or human-compiled expression.
    /// </summary>
    public CodeableConcept Type { get; set; }
    /// <summary>
    /// Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred. Multiple instances may share the same URL if they have a distinct version.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
    /// </summary>
    public List<UsageContext> UseContext { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR4.Models.DomainResource)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Url))
      {
        writer.WriteString("url", (string)Url!);
      }

      if (_Url != null)
      {
        writer.WritePropertyName("_url");
        _Url.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if ((UseContext != null) && (UseContext.Count != 0))
      {
        writer.WritePropertyName("useContext");
        writer.WriteStartArray();

        foreach (UsageContext valUseContext in UseContext)
        {
          valUseContext.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((RelatedIdentifier != null) && (RelatedIdentifier.Count != 0))
      {
        writer.WritePropertyName("relatedIdentifier");
        writer.WriteStartArray();

        foreach (Identifier valRelatedIdentifier in RelatedIdentifier)
        {
          valRelatedIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (CiteAsReference != null)
      {
        writer.WritePropertyName("citeAsReference");
        CiteAsReference.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(CiteAsMarkdown))
      {
        writer.WriteString("citeAsMarkdown", (string)CiteAsMarkdown!);
      }

      if (_CiteAsMarkdown != null)
      {
        writer.WritePropertyName("_citeAsMarkdown");
        _CiteAsMarkdown.SerializeJson(writer, options);
      }

      if (Type != null)
      {
        writer.WritePropertyName("type");
        Type.SerializeJson(writer, options);
      }

      if ((Note != null) && (Note.Count != 0))
      {
        writer.WritePropertyName("note");
        writer.WriteStartArray();

        foreach (Annotation valNote in Note)
        {
          valNote.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((RelatedArtifact != null) && (RelatedArtifact.Count != 0))
      {
        writer.WritePropertyName("relatedArtifact");
        writer.WriteStartArray();

        foreach (RelatedArtifact valRelatedArtifact in RelatedArtifact)
        {
          valRelatedArtifact.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Subject != null)
      {
        writer.WritePropertyName("subject");
        Subject.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Publisher))
      {
        writer.WriteString("publisher", (string)Publisher!);
      }

      if (_Publisher != null)
      {
        writer.WritePropertyName("_publisher");
        _Publisher.SerializeJson(writer, options);
      }

      if ((Contact != null) && (Contact.Count != 0))
      {
        writer.WritePropertyName("contact");
        writer.WriteStartArray();

        foreach (ContactDetail valContact in Contact)
        {
          valContact.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Author != null) && (Author.Count != 0))
      {
        writer.WritePropertyName("author");
        writer.WriteStartArray();

        foreach (ContactDetail valAuthor in Author)
        {
          valAuthor.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Editor != null) && (Editor.Count != 0))
      {
        writer.WritePropertyName("editor");
        writer.WriteStartArray();

        foreach (ContactDetail valEditor in Editor)
        {
          valEditor.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Reviewer != null) && (Reviewer.Count != 0))
      {
        writer.WritePropertyName("reviewer");
        writer.WriteStartArray();

        foreach (ContactDetail valReviewer in Reviewer)
        {
          valReviewer.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Endorser != null) && (Endorser.Count != 0))
      {
        writer.WritePropertyName("endorser");
        writer.WriteStartArray();

        foreach (ContactDetail valEndorser in Endorser)
        {
          valEndorser.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((RelatesTo != null) && (RelatesTo.Count != 0))
      {
        writer.WritePropertyName("relatesTo");
        writer.WriteStartArray();

        foreach (EvidenceReportRelatesTo valRelatesTo in RelatesTo)
        {
          valRelatesTo.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Section != null) && (Section.Count != 0))
      {
        writer.WritePropertyName("section");
        writer.WriteStartArray();

        foreach (EvidenceReportSection valSection in Section)
        {
          valSection.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "author":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Author = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ContactDetail objAuthor = new fhirCsR4.Models.ContactDetail();
            objAuthor.DeserializeJson(ref reader, options);
            Author.Add(objAuthor);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Author.Count == 0)
          {
            Author = null;
          }

          break;

        case "citeAsReference":
          CiteAsReference = new fhirCsR4.Models.Reference();
          CiteAsReference.DeserializeJson(ref reader, options);
          break;

        case "citeAsMarkdown":
          CiteAsMarkdown = reader.GetString();
          break;

        case "_citeAsMarkdown":
          _CiteAsMarkdown = new fhirCsR4.Models.Element();
          _CiteAsMarkdown.DeserializeJson(ref reader, options);
          break;

        case "contact":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Contact = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ContactDetail objContact = new fhirCsR4.Models.ContactDetail();
            objContact.DeserializeJson(ref reader, options);
            Contact.Add(objContact);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Contact.Count == 0)
          {
            Contact = null;
          }

          break;

        case "editor":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Editor = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ContactDetail objEditor = new fhirCsR4.Models.ContactDetail();
            objEditor.DeserializeJson(ref reader, options);
            Editor.Add(objEditor);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Editor.Count == 0)
          {
            Editor = null;
          }

          break;

        case "endorser":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Endorser = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ContactDetail objEndorser = new fhirCsR4.Models.ContactDetail();
            objEndorser.DeserializeJson(ref reader, options);
            Endorser.Add(objEndorser);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Endorser.Count == 0)
          {
            Endorser = null;
          }

          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Identifier objIdentifier = new fhirCsR4.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "note":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Note = new List<Annotation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Annotation objNote = new fhirCsR4.Models.Annotation();
            objNote.DeserializeJson(ref reader, options);
            Note.Add(objNote);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Note.Count == 0)
          {
            Note = null;
          }

          break;

        case "publisher":
          Publisher = reader.GetString();
          break;

        case "_publisher":
          _Publisher = new fhirCsR4.Models.Element();
          _Publisher.DeserializeJson(ref reader, options);
          break;

        case "relatedArtifact":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          RelatedArtifact = new List<RelatedArtifact>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.RelatedArtifact objRelatedArtifact = new fhirCsR4.Models.RelatedArtifact();
            objRelatedArtifact.DeserializeJson(ref reader, options);
            RelatedArtifact.Add(objRelatedArtifact);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (RelatedArtifact.Count == 0)
          {
            RelatedArtifact = null;
          }

          break;

        case "relatedIdentifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          RelatedIdentifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.Identifier objRelatedIdentifier = new fhirCsR4.Models.Identifier();
            objRelatedIdentifier.DeserializeJson(ref reader, options);
            RelatedIdentifier.Add(objRelatedIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (RelatedIdentifier.Count == 0)
          {
            RelatedIdentifier = null;
          }

          break;

        case "relatesTo":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          RelatesTo = new List<EvidenceReportRelatesTo>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.EvidenceReportRelatesTo objRelatesTo = new fhirCsR4.Models.EvidenceReportRelatesTo();
            objRelatesTo.DeserializeJson(ref reader, options);
            RelatesTo.Add(objRelatesTo);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (RelatesTo.Count == 0)
          {
            RelatesTo = null;
          }

          break;

        case "reviewer":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Reviewer = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.ContactDetail objReviewer = new fhirCsR4.Models.ContactDetail();
            objReviewer.DeserializeJson(ref reader, options);
            Reviewer.Add(objReviewer);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Reviewer.Count == 0)
          {
            Reviewer = null;
          }

          break;

        case "section":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Section = new List<EvidenceReportSection>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.EvidenceReportSection objSection = new fhirCsR4.Models.EvidenceReportSection();
            objSection.DeserializeJson(ref reader, options);
            Section.Add(objSection);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Section.Count == 0)
          {
            Section = null;
          }

          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR4.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "subject":
          Subject = new fhirCsR4.Models.EvidenceReportSubject();
          Subject.DeserializeJson(ref reader, options);
          break;

        case "type":
          Type = new fhirCsR4.Models.CodeableConcept();
          Type.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new fhirCsR4.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        case "useContext":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          UseContext = new List<UsageContext>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4.Models.UsageContext objUseContext = new fhirCsR4.Models.UsageContext();
            objUseContext.DeserializeJson(ref reader, options);
            UseContext.Add(objUseContext);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (UseContext.Count == 0)
          {
            UseContext = null;
          }

          break;

        default:
          ((fhirCsR4.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the EvidenceReport.status field
  /// </summary>
  public static class EvidenceReportStatusCodes {
    public const string DRAFT = "draft";
    public const string ACTIVE = "active";
    public const string RETIRED = "retired";
    public const string UNKNOWN = "unknown";
  }
}
